/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/colorDistance/CompareFn.ts":
/*!****************************************!*\
  !*** ./src/colorDistance/CompareFn.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"colDistRGB\": () => (/* binding */ colDistRGB),\n/* harmony export */   \"colDistRGBL\": () => (/* binding */ colDistRGBL),\n/* harmony export */   \"colDistLinearL\": () => (/* binding */ colDistLinearL),\n/* harmony export */   \"colDistLab\": () => (/* binding */ colDistLab),\n/* harmony export */   \"getColorDistanceFnById\": () => (/* binding */ getColorDistanceFnById)\n/* harmony export */ });\n/* harmony import */ var _utils_colorUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/colorUtils */ \"./src/utils/colorUtils.ts\");\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/utils */ \"./src/utils/utils.ts\");\n\n\n// Simple, fast sRGB space distance calculation.\nfunction colDistRGB(color1, color2) {\n    return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.vec3distance)(color1, color2);\n}\nfunction colDistRGBL(color1, color2) {\n    const luma1 = (0,_utils_colorUtils__WEBPACK_IMPORTED_MODULE_0__.luma_srgb)(color1), luma2 = (0,_utils_colorUtils__WEBPACK_IMPORTED_MODULE_0__.luma_srgb)(color2);\n    const dLuma = luma1 - luma2;\n    const dColor = color1.map((ch, i) => ch - color2[i]);\n    return (dColor[0] * dColor[0] * 0.299 + dColor[1] * dColor[1] * 0.587 + dColor[2] * dColor[2] * 0.114) * 0.75 * dLuma * dLuma;\n}\n// Linear space calculation.\nfunction colDistLinearL(color1, color2) {\n    return colDistRGBL((0,_utils_colorUtils__WEBPACK_IMPORTED_MODULE_0__.linear2srgb)(color1), (0,_utils_colorUtils__WEBPACK_IMPORTED_MODULE_0__.linear2srgb)(color2));\n}\nconst labCache = {};\n// Computes color distance in CIE-L*ab space. Slower, but more visually accurate.\nfunction colDistLab(color1, color2) {\n    const c1index = color1[0] + (color1[1] << 8) + (color1[2] << 16);\n    const c2index = color2[0] + (color2[1] << 8) + (color2[2] << 16);\n    let lab1 = labCache[c1index];\n    if (!lab1) {\n        lab1 = (0,_utils_colorUtils__WEBPACK_IMPORTED_MODULE_0__.srgb2lab)(color1);\n        labCache[c1index] = lab1;\n    }\n    let lab2 = labCache[c2index];\n    if (!lab2) {\n        lab2 = (0,_utils_colorUtils__WEBPACK_IMPORTED_MODULE_0__.srgb2lab)(color2);\n        labCache[c2index] = lab2;\n    }\n    return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.vec3distance)(lab1, lab2);\n}\nconst getColorDistanceFnById = (id) => {\n    switch (id) {\n        case 'cdLab':\n            return colDistLab;\n        case 'cdRGB':\n        default:\n            return colDistRGB;\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbWFnZWJpdGRlcHRoLy4vc3JjL2NvbG9yRGlzdGFuY2UvQ29tcGFyZUZuLnRzP2FjNDMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUF1RTtBQUN6QjtBQUM5QztBQUNPO0FBQ1AsV0FBVywwREFBWTtBQUN2QjtBQUNPO0FBQ1Asa0JBQWtCLDREQUFTLGtCQUFrQiw0REFBUztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCx1QkFBdUIsOERBQVcsVUFBVSw4REFBVztBQUN2RDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwyREFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMkRBQVE7QUFDdkI7QUFDQTtBQUNBLFdBQVcsMERBQVk7QUFDdkI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9zcmMvY29sb3JEaXN0YW5jZS9Db21wYXJlRm4udHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBsaW5lYXIyc3JnYiwgbHVtYV9zcmdiLCBzcmdiMmxhYiB9IGZyb20gJy4uL3V0aWxzL2NvbG9yVXRpbHMnO1xuaW1wb3J0IHsgdmVjM2Rpc3RhbmNlIH0gZnJvbSAnLi4vdXRpbHMvdXRpbHMnO1xuLy8gU2ltcGxlLCBmYXN0IHNSR0Igc3BhY2UgZGlzdGFuY2UgY2FsY3VsYXRpb24uXG5leHBvcnQgZnVuY3Rpb24gY29sRGlzdFJHQihjb2xvcjEsIGNvbG9yMikge1xuICAgIHJldHVybiB2ZWMzZGlzdGFuY2UoY29sb3IxLCBjb2xvcjIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbERpc3RSR0JMKGNvbG9yMSwgY29sb3IyKSB7XG4gICAgY29uc3QgbHVtYTEgPSBsdW1hX3NyZ2IoY29sb3IxKSwgbHVtYTIgPSBsdW1hX3NyZ2IoY29sb3IyKTtcbiAgICBjb25zdCBkTHVtYSA9IGx1bWExIC0gbHVtYTI7XG4gICAgY29uc3QgZENvbG9yID0gY29sb3IxLm1hcCgoY2gsIGkpID0+IGNoIC0gY29sb3IyW2ldKTtcbiAgICByZXR1cm4gKGRDb2xvclswXSAqIGRDb2xvclswXSAqIDAuMjk5ICsgZENvbG9yWzFdICogZENvbG9yWzFdICogMC41ODcgKyBkQ29sb3JbMl0gKiBkQ29sb3JbMl0gKiAwLjExNCkgKiAwLjc1ICogZEx1bWEgKiBkTHVtYTtcbn1cbi8vIExpbmVhciBzcGFjZSBjYWxjdWxhdGlvbi5cbmV4cG9ydCBmdW5jdGlvbiBjb2xEaXN0TGluZWFyTChjb2xvcjEsIGNvbG9yMikge1xuICAgIHJldHVybiBjb2xEaXN0UkdCTChsaW5lYXIyc3JnYihjb2xvcjEpLCBsaW5lYXIyc3JnYihjb2xvcjIpKTtcbn1cbmNvbnN0IGxhYkNhY2hlID0ge307XG4vLyBDb21wdXRlcyBjb2xvciBkaXN0YW5jZSBpbiBDSUUtTCphYiBzcGFjZS4gU2xvd2VyLCBidXQgbW9yZSB2aXN1YWxseSBhY2N1cmF0ZS5cbmV4cG9ydCBmdW5jdGlvbiBjb2xEaXN0TGFiKGNvbG9yMSwgY29sb3IyKSB7XG4gICAgY29uc3QgYzFpbmRleCA9IGNvbG9yMVswXSArIChjb2xvcjFbMV0gPDwgOCkgKyAoY29sb3IxWzJdIDw8IDE2KTtcbiAgICBjb25zdCBjMmluZGV4ID0gY29sb3IyWzBdICsgKGNvbG9yMlsxXSA8PCA4KSArIChjb2xvcjJbMl0gPDwgMTYpO1xuICAgIGxldCBsYWIxID0gbGFiQ2FjaGVbYzFpbmRleF07XG4gICAgaWYgKCFsYWIxKSB7XG4gICAgICAgIGxhYjEgPSBzcmdiMmxhYihjb2xvcjEpO1xuICAgICAgICBsYWJDYWNoZVtjMWluZGV4XSA9IGxhYjE7XG4gICAgfVxuICAgIGxldCBsYWIyID0gbGFiQ2FjaGVbYzJpbmRleF07XG4gICAgaWYgKCFsYWIyKSB7XG4gICAgICAgIGxhYjIgPSBzcmdiMmxhYihjb2xvcjIpO1xuICAgICAgICBsYWJDYWNoZVtjMmluZGV4XSA9IGxhYjI7XG4gICAgfVxuICAgIHJldHVybiB2ZWMzZGlzdGFuY2UobGFiMSwgbGFiMik7XG59XG5leHBvcnQgY29uc3QgZ2V0Q29sb3JEaXN0YW5jZUZuQnlJZCA9IChpZCkgPT4ge1xuICAgIHN3aXRjaCAoaWQpIHtcbiAgICAgICAgY2FzZSAnY2RMYWInOlxuICAgICAgICAgICAgcmV0dXJuIGNvbERpc3RMYWI7XG4gICAgICAgIGNhc2UgJ2NkUkdCJzpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBjb2xEaXN0UkdCO1xuICAgIH1cbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/colorDistance/CompareFn.ts\n");

/***/ }),

/***/ "./src/palette/PaletteGroups.ts":
/*!**************************************!*\
  !*** ./src/palette/PaletteGroups.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nvar PaletteType;\n(function (PaletteType) {\n    PaletteType[\"P2BitIndexed\"] = \"2-bit (4 color) Indexed\";\n    PaletteType[\"P4BitRGBI\"] = \"4-bit (16 color) RGBI\";\n    PaletteType[\"P4BitIndexed\"] = \"4-bit (16 color) Indexed\";\n    PaletteType[\"PMono\"] = \"Monochrome\";\n    PaletteType[\"PRGB\"] = \"RGB\";\n    PaletteType[\"PAuto\"] = \"Optimized (Auto)\";\n    PaletteType[\"POther\"] = \"Other\";\n})(PaletteType || (PaletteType = {}));\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PaletteType);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbWFnZWJpdGRlcHRoLy4vc3JjL3BhbGV0dGUvUGFsZXR0ZUdyb3Vwcy50cz80MzEzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtDQUFrQztBQUNuQyxpRUFBZSxXQUFXLEVBQUMiLCJmaWxlIjoiLi9zcmMvcGFsZXR0ZS9QYWxldHRlR3JvdXBzLnRzLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIFBhbGV0dGVUeXBlO1xuKGZ1bmN0aW9uIChQYWxldHRlVHlwZSkge1xuICAgIFBhbGV0dGVUeXBlW1wiUDJCaXRJbmRleGVkXCJdID0gXCIyLWJpdCAoNCBjb2xvcikgSW5kZXhlZFwiO1xuICAgIFBhbGV0dGVUeXBlW1wiUDRCaXRSR0JJXCJdID0gXCI0LWJpdCAoMTYgY29sb3IpIFJHQklcIjtcbiAgICBQYWxldHRlVHlwZVtcIlA0Qml0SW5kZXhlZFwiXSA9IFwiNC1iaXQgKDE2IGNvbG9yKSBJbmRleGVkXCI7XG4gICAgUGFsZXR0ZVR5cGVbXCJQTW9ub1wiXSA9IFwiTW9ub2Nocm9tZVwiO1xuICAgIFBhbGV0dGVUeXBlW1wiUFJHQlwiXSA9IFwiUkdCXCI7XG4gICAgUGFsZXR0ZVR5cGVbXCJQQXV0b1wiXSA9IFwiT3B0aW1pemVkIChBdXRvKVwiO1xuICAgIFBhbGV0dGVUeXBlW1wiUE90aGVyXCJdID0gXCJPdGhlclwiO1xufSkoUGFsZXR0ZVR5cGUgfHwgKFBhbGV0dGVUeXBlID0ge30pKTtcbmV4cG9ydCBkZWZhdWx0IFBhbGV0dGVUeXBlO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/palette/PaletteGroups.ts\n");

/***/ }),

/***/ "./src/palette/paletteMap.ts":
/*!***********************************!*\
  !*** ./src/palette/paletteMap.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"paletteMap\": () => (/* binding */ paletteMap)\n/* harmony export */ });\n/* harmony import */ var _PaletteGroups__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PaletteGroups */ \"./src/palette/PaletteGroups.ts\");\n\n// Default palette mapping\n// Uses a simple distance check\nfunction defPaletteMap(color, palette, distFn) {\n    let closest = [];\n    let dMin = Number.POSITIVE_INFINITY;\n    palette.data.forEach(pColor => {\n        const dsq = distFn(color, pColor);\n        if (dsq <= dMin) {\n            closest = pColor;\n            dMin = dsq;\n        }\n    });\n    return closest;\n}\nfunction clampedRGBPaletteMap(color, palette) {\n    const levels = palette.data[0].map(bits => Math.pow(2, bits));\n    const clamped = [...color];\n    for (let i = 0; i < 3; i++) {\n        const segment = ~~(color[i] / (256 / levels[i]));\n        clamped[i] = segment * (255 / (levels[i] - 1));\n    }\n    return clamped;\n}\nfunction paletteMap(color, palette, distFn) {\n    switch (palette.type) {\n        case _PaletteGroups__WEBPACK_IMPORTED_MODULE_0__.default.PRGB:\n            return clampedRGBPaletteMap(color, palette);\n        default:\n            return defPaletteMap(color, palette, distFn);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbWFnZWJpdGRlcHRoLy4vc3JjL3BhbGV0dGUvcGFsZXR0ZU1hcC50cz9mM2M5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsYUFBYSx3REFBZ0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL3NyYy9wYWxldHRlL3BhbGV0dGVNYXAudHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUGFsZXR0ZVR5cGUgZnJvbSAnLi9QYWxldHRlR3JvdXBzJztcbi8vIERlZmF1bHQgcGFsZXR0ZSBtYXBwaW5nXG4vLyBVc2VzIGEgc2ltcGxlIGRpc3RhbmNlIGNoZWNrXG5mdW5jdGlvbiBkZWZQYWxldHRlTWFwKGNvbG9yLCBwYWxldHRlLCBkaXN0Rm4pIHtcbiAgICBsZXQgY2xvc2VzdCA9IFtdO1xuICAgIGxldCBkTWluID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIHBhbGV0dGUuZGF0YS5mb3JFYWNoKHBDb2xvciA9PiB7XG4gICAgICAgIGNvbnN0IGRzcSA9IGRpc3RGbihjb2xvciwgcENvbG9yKTtcbiAgICAgICAgaWYgKGRzcSA8PSBkTWluKSB7XG4gICAgICAgICAgICBjbG9zZXN0ID0gcENvbG9yO1xuICAgICAgICAgICAgZE1pbiA9IGRzcTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjbG9zZXN0O1xufVxuZnVuY3Rpb24gY2xhbXBlZFJHQlBhbGV0dGVNYXAoY29sb3IsIHBhbGV0dGUpIHtcbiAgICBjb25zdCBsZXZlbHMgPSBwYWxldHRlLmRhdGFbMF0ubWFwKGJpdHMgPT4gTWF0aC5wb3coMiwgYml0cykpO1xuICAgIGNvbnN0IGNsYW1wZWQgPSBbLi4uY29sb3JdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHNlZ21lbnQgPSB+fihjb2xvcltpXSAvICgyNTYgLyBsZXZlbHNbaV0pKTtcbiAgICAgICAgY2xhbXBlZFtpXSA9IHNlZ21lbnQgKiAoMjU1IC8gKGxldmVsc1tpXSAtIDEpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNsYW1wZWQ7XG59XG5leHBvcnQgZnVuY3Rpb24gcGFsZXR0ZU1hcChjb2xvciwgcGFsZXR0ZSwgZGlzdEZuKSB7XG4gICAgc3dpdGNoIChwYWxldHRlLnR5cGUpIHtcbiAgICAgICAgY2FzZSBQYWxldHRlVHlwZS5QUkdCOlxuICAgICAgICAgICAgcmV0dXJuIGNsYW1wZWRSR0JQYWxldHRlTWFwKGNvbG9yLCBwYWxldHRlKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBkZWZQYWxldHRlTWFwKGNvbG9yLCBwYWxldHRlLCBkaXN0Rm4pO1xuICAgIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/palette/paletteMap.ts\n");

/***/ }),

/***/ "./src/paletteGen/ColorNode.ts":
/*!*************************************!*\
  !*** ./src/paletteGen/ColorNode.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nclass ColorNode {\n    constructor() {\n        this.colors = [];\n        this.pixels = 0;\n    }\n    get pixelCount() { return this.pixels; }\n    get avgColor() {\n        const sum = [0, 0, 0];\n        for (let i = 0; i < this.colors.length; i++)\n            for (let j = 0; j < 3; j++)\n                sum[j] += this.colors[i][j];\n        return sum.map(v => v / this.colors.length);\n    }\n    addColor(color) {\n        // If the specific color isn't in the list, add it\n        // Either way, increase the pixel count by one\n        if (!this.colors.includes(color))\n            this.colors.push(color);\n        this.pixels++;\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ColorNode);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbWFnZWJpdGRlcHRoLy4vc3JjL3BhbGV0dGVHZW4vQ29sb3JOb2RlLnRzPzQ4NmQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQSx1QkFBdUIsd0JBQXdCO0FBQy9DLDJCQUEyQixPQUFPO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBZSxTQUFTLEVBQUMiLCJmaWxlIjoiLi9zcmMvcGFsZXR0ZUdlbi9Db2xvck5vZGUudHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyBDb2xvck5vZGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNvbG9ycyA9IFtdO1xuICAgICAgICB0aGlzLnBpeGVscyA9IDA7XG4gICAgfVxuICAgIGdldCBwaXhlbENvdW50KCkgeyByZXR1cm4gdGhpcy5waXhlbHM7IH1cbiAgICBnZXQgYXZnQ29sb3IoKSB7XG4gICAgICAgIGNvbnN0IHN1bSA9IFswLCAwLCAwXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNvbG9ycy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgMzsgaisrKVxuICAgICAgICAgICAgICAgIHN1bVtqXSArPSB0aGlzLmNvbG9yc1tpXVtqXTtcbiAgICAgICAgcmV0dXJuIHN1bS5tYXAodiA9PiB2IC8gdGhpcy5jb2xvcnMubGVuZ3RoKTtcbiAgICB9XG4gICAgYWRkQ29sb3IoY29sb3IpIHtcbiAgICAgICAgLy8gSWYgdGhlIHNwZWNpZmljIGNvbG9yIGlzbid0IGluIHRoZSBsaXN0LCBhZGQgaXRcbiAgICAgICAgLy8gRWl0aGVyIHdheSwgaW5jcmVhc2UgdGhlIHBpeGVsIGNvdW50IGJ5IG9uZVxuICAgICAgICBpZiAoIXRoaXMuY29sb3JzLmluY2x1ZGVzKGNvbG9yKSlcbiAgICAgICAgICAgIHRoaXMuY29sb3JzLnB1c2goY29sb3IpO1xuICAgICAgICB0aGlzLnBpeGVscysrO1xuICAgIH1cbn1cbmV4cG9ydCBkZWZhdWx0IENvbG9yTm9kZTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/paletteGen/ColorNode.ts\n");

/***/ }),

/***/ "./src/paletteGen/PaletteGenerator.ts":
/*!********************************************!*\
  !*** ./src/paletteGen/PaletteGenerator.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"generatePalette\": () => (/* binding */ generatePalette)\n/* harmony export */ });\n/* harmony import */ var _palette_PaletteGroups__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../palette/PaletteGroups */ \"./src/palette/PaletteGroups.ts\");\n/* harmony import */ var _ColorNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ColorNode */ \"./src/paletteGen/ColorNode.ts\");\n\n\n// Sample every n pixels in the x and y axes (1/n^2 pixels total)\nconst SUBSAMPLING = 2;\nfunction makeTree(levels) {\n    return Array.from({ length: Math.pow(8, levels) }, () => new _ColorNode__WEBPACK_IMPORTED_MODULE_1__.default());\n}\n// Octree-based color quantizer\nclass PaletteGenerator {\n    constructor(opts) {\n        this.generated = false;\n        this.levels = opts.levels;\n        this.tree = makeTree(opts.levels);\n        this.ctes = [];\n        this.reservedLevel = opts.reservedLevel;\n        this.nColors = opts.numColors;\n        this.k = opts.inclThresholdCoeff || 1;\n    }\n    // Add a color to the appropriate leaf node (octcube)\n    // Returns the index of the leaf node the color was added to\n    addColor(color) {\n        if (this.generated)\n            throw new Error('Attempting to modify a generated palette');\n        const i = this.index(color);\n        this.tree[i].addColor(color);\n        return i;\n    }\n    getPalette() {\n        if (!this.generated)\n            this.generate();\n        const colors = [];\n        this.ctes.forEach(cte => {\n            const index = cte.index;\n            const color = [0, 0, 0];\n            for (let n = 0; n < cte.level; n++) {\n                for (let i = 2; i >= 0; i--) {\n                    const bit = (cte.level - 1 - n) * 3 + i;\n                    const mask = (0x1 << (cte.level * 3 - 1)) >> (n * 3 + (2 - i));\n                    color[2 - i] = (color[2 - i] << 1) | ((index & mask) >> bit);\n                }\n            }\n            for (let n = cte.level; n < 8; n++)\n                for (let i = 0; i < 3; i++)\n                    color[i] = (color[i] << 1) | (n === cte.level ? 0x1 : 0x0);\n            colors.push(color);\n            //colors.push(cte.node.avgColor);\n        });\n        console.log(`Built palette with ${colors.length} colors`);\n        return colors;\n    }\n    // Returns an index for the virtual octree at level (N)\n    // By design the octcube (i) at level (n - 1) contains the\n    // octcubes (8i + j; j in 0-7) at level (n)\n    //\n    // In other words, shifting the index at level (n) three \n    // bits to the right yields the index of the color at level (n - 1)\n    index(color) {\n        let index = 0;\n        for (let n = 0; n < this.levels; n++) {\n            const bit = 7 - n;\n            let iLevel = 0;\n            for (let i = 0; i < 3; i++) {\n                // For each channel, get the nth bit starting from the MSB\n                // and combine them in a number in range 1-8\n                // This is our index for the level n (relative to level n-1)\n                const mask = 0x80 >> n;\n                iLevel = (iLevel << 1) | ((color[i] & mask) >> bit);\n            }\n            // Shift the 'global' index by 3 bits and add the new level index\n            // The result is the 'absolute' index of the lowest level octcube\n            // the color fits in\n            index = (index << 3) | iLevel;\n        }\n        return index;\n    }\n    // Returns the properties for any given node\n    // Only leaf nodes are actually stored; for any other node,\n    // a 'fake' node with its properties calculated on the fly\n    // is returned\n    getNode(index, level) {\n        if (level === this.levels)\n            return this.tree[index];\n        const children = [];\n        for (let j = 0; j < 8; j++)\n            if (!this.isCTE(8 * index + j, level + 1))\n                children.push(this.getNode(8 * index + j, level + 1));\n        const fakeNode = children\n            .filter(node => node.pixelCount > 0)\n            .reduce((acc, node) => ({\n            //avgColor: acc.avgColor.map((ch, i) => ch + node.avgColor[i]),\n            pixelCount: acc.pixelCount + node.pixelCount\n        }), { /*avgColor: [0, 0, 0],*/ pixelCount: 0 });\n        // Produce average from the sum of the eight child nodes\n        //fakeNode.avgColor = fakeNode.avgColor.map(ch => ch / 8);\n        //if (fakeNode.avgColor.some(ch => isNaN(ch)))\n        //  console.warn(`broken color @${index}, level ${level}`);\n        return fakeNode;\n    }\n    isCTE(index, level) {\n        return this.ctes.some(cte => cte.index === index && cte.level === level);\n    }\n    markCTE(index, level, node) {\n        this.ctes.push({ index, level, node });\n    }\n    testNode(nCols, nRes, nPix, node) {\n        // Get the number of colors yet to be assigned\n        const unassignedColors = nCols - nRes - this.ctes.length;\n        // Get the total number of pixels sampled and the number\n        // of pixels assigned to some CTE, and subtract to get\n        // the number of pixels left to assign\n        const unassignedPixels = nPix - this.ctes\n            .map(cte => cte.node.pixelCount)\n            .reduce((acc, v) => acc + v, 0);\n        const threshold = unassignedPixels / unassignedColors * this.k;\n        // If the node has more pixels than the number of pixels left\n        // to assign divided by the number of available colors, then\n        // it should get a color in the palette\n        return node.pixelCount > threshold;\n    }\n    get nonReservedCTEs() {\n        return this.ctes.filter(cte => cte.level !== this.reservedLevel).length;\n    }\n    generate() {\n        if (this.generated)\n            throw new Error('This palette has already been generated');\n        this.generated = true;\n        const reserved = this.reservedLevel < 0 ? 0 : Math.pow(8, this.reservedLevel);\n        const sampled = this.getNode(0, 0).pixelCount;\n        let level;\n        let lastIterationCTEs = 0;\n        let stuckCounter = 0;\n        // Repeat until the palette is full!\n        while (this.nColors - reserved - this.nonReservedCTEs > 0) {\n            level = this.levels; // Start at leaf node level\n            // Prune up until the specified level\n            // All colors in that level are then reserved\n            while (level > this.reservedLevel && level > 0) {\n                const nodes = Math.pow(8, level);\n                // Iterate through all nodes in the level\n                for (let i = 0; i < nodes; i++) {\n                    const node = this.getNode(i, level);\n                    // If the node is not yet a CTE, and has enough pixels to be\n                    // one, make it a CTE\n                    if (!this.isCTE(i, level) && this.testNode(this.nColors, reserved, sampled, node))\n                        this.markCTE(i, level, node);\n                    // Every 8th node, check the last 8 nodes\n                    // If any nodes are a CTE, make the parent a CTE UNLESS all 8 nodes are CTEs\n                    if (i % 8 === 7) {\n                        let ctes = 0;\n                        for (let j = i - 7; j <= i; j++)\n                            if (this.isCTE(j, level))\n                                ctes++;\n                        if (ctes > 0 && ctes < 8) {\n                            const iParent = i >> 3;\n                            if (!this.isCTE(iParent, level - 1))\n                                this.markCTE(iParent, level - 1, this.getNode(iParent, level - 1));\n                        }\n                    }\n                    // Stop if the palette is full\n                    if (this.nColors - reserved - this.nonReservedCTEs <= 0) {\n                        //console.warn(`Ran out of colors! At node ${i}, level ${level}`);\n                        break;\n                    }\n                }\n                // Stop if the palette is full\n                if (this.nColors - reserved - this.nonReservedCTEs <= 0) {\n                    //console.warn(`Ran out of colors! At level ${level}`);\n                    break;\n                }\n                level--;\n            }\n            //console.log(`${this.ctes.length} CTEs, ${this.ctes.length - this.nonReservedCTEs} reserved`);\n            if (this.ctes.length === lastIterationCTEs) {\n                this.k = this.k / 2;\n                stuckCounter++;\n                if (stuckCounter >= 5)\n                    break;\n            }\n            lastIterationCTEs = this.ctes.length;\n        }\n        // Finally, handle reserved colors\n        if (this.reservedLevel >= 0) {\n            level = this.reservedLevel;\n            const nodes = Math.pow(8, level);\n            for (let i = 0; i < nodes; i++) {\n                const node = this.getNode(i, level);\n                // If the node is not yet a CTE, make it one\n                if (!this.isCTE(i, level))\n                    this.markCTE(i, level, node);\n            }\n        }\n    }\n}\nfunction generatePalette(opts, img) {\n    const octree = new PaletteGenerator(opts);\n    const size = img.width * img.height * 4;\n    for (let i = 0; i < size; i += 4) {\n        const y = ~~(i / 4 / img.width);\n        const x = ~~(i / 4 % img.width);\n        if (x % SUBSAMPLING === 0 && y % SUBSAMPLING === 0) {\n            const color = Array.from(img.data.slice(i, i + 4));\n            octree.addColor(color);\n        }\n    }\n    const colors = octree.getPalette();\n    return {\n        name: '__GENERATED__',\n        type: _palette_PaletteGroups__WEBPACK_IMPORTED_MODULE_0__.default.POther,\n        useAlpha: false,\n        data: colors\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbWFnZWJpdGRlcHRoLy4vc3JjL3BhbGV0dGVHZW4vUGFsZXR0ZUdlbmVyYXRvci50cz8wNzc3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFtRDtBQUNmO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw4QkFBOEIsWUFBWSwrQ0FBUztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixlQUFlO0FBQzFDLCtCQUErQixRQUFRO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsT0FBTztBQUMxQywrQkFBK0IsT0FBTztBQUN0QztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsMENBQTBDLGNBQWM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTtBQUNBLDJCQUEyQixPQUFPO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLE9BQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQUkseUNBQXlDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxNQUFNLFVBQVUsTUFBTTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFdBQVc7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFFBQVE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsRUFBRSxVQUFVLE1BQU07QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxNQUFNO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGlCQUFpQixTQUFTLHdDQUF3QztBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsV0FBVztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGtFQUFrQjtBQUNoQztBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL3NyYy9wYWxldHRlR2VuL1BhbGV0dGVHZW5lcmF0b3IudHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUGFsZXR0ZVR5cGUgZnJvbSAnLi4vcGFsZXR0ZS9QYWxldHRlR3JvdXBzJztcbmltcG9ydCBDb2xvck5vZGUgZnJvbSAnLi9Db2xvck5vZGUnO1xuLy8gU2FtcGxlIGV2ZXJ5IG4gcGl4ZWxzIGluIHRoZSB4IGFuZCB5IGF4ZXMgKDEvbl4yIHBpeGVscyB0b3RhbClcbmNvbnN0IFNVQlNBTVBMSU5HID0gMjtcbmZ1bmN0aW9uIG1ha2VUcmVlKGxldmVscykge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHsgbGVuZ3RoOiBNYXRoLnBvdyg4LCBsZXZlbHMpIH0sICgpID0+IG5ldyBDb2xvck5vZGUoKSk7XG59XG4vLyBPY3RyZWUtYmFzZWQgY29sb3IgcXVhbnRpemVyXG5jbGFzcyBQYWxldHRlR2VuZXJhdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHRoaXMuZ2VuZXJhdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGV2ZWxzID0gb3B0cy5sZXZlbHM7XG4gICAgICAgIHRoaXMudHJlZSA9IG1ha2VUcmVlKG9wdHMubGV2ZWxzKTtcbiAgICAgICAgdGhpcy5jdGVzID0gW107XG4gICAgICAgIHRoaXMucmVzZXJ2ZWRMZXZlbCA9IG9wdHMucmVzZXJ2ZWRMZXZlbDtcbiAgICAgICAgdGhpcy5uQ29sb3JzID0gb3B0cy5udW1Db2xvcnM7XG4gICAgICAgIHRoaXMuayA9IG9wdHMuaW5jbFRocmVzaG9sZENvZWZmIHx8IDE7XG4gICAgfVxuICAgIC8vIEFkZCBhIGNvbG9yIHRvIHRoZSBhcHByb3ByaWF0ZSBsZWFmIG5vZGUgKG9jdGN1YmUpXG4gICAgLy8gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGxlYWYgbm9kZSB0aGUgY29sb3Igd2FzIGFkZGVkIHRvXG4gICAgYWRkQ29sb3IoY29sb3IpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2VuZXJhdGVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdHRlbXB0aW5nIHRvIG1vZGlmeSBhIGdlbmVyYXRlZCBwYWxldHRlJyk7XG4gICAgICAgIGNvbnN0IGkgPSB0aGlzLmluZGV4KGNvbG9yKTtcbiAgICAgICAgdGhpcy50cmVlW2ldLmFkZENvbG9yKGNvbG9yKTtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICAgIGdldFBhbGV0dGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5nZW5lcmF0ZWQpXG4gICAgICAgICAgICB0aGlzLmdlbmVyYXRlKCk7XG4gICAgICAgIGNvbnN0IGNvbG9ycyA9IFtdO1xuICAgICAgICB0aGlzLmN0ZXMuZm9yRWFjaChjdGUgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBjdGUuaW5kZXg7XG4gICAgICAgICAgICBjb25zdCBjb2xvciA9IFswLCAwLCAwXTtcbiAgICAgICAgICAgIGZvciAobGV0IG4gPSAwOyBuIDwgY3RlLmxldmVsOyBuKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMjsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYml0ID0gKGN0ZS5sZXZlbCAtIDEgLSBuKSAqIDMgKyBpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXNrID0gKDB4MSA8PCAoY3RlLmxldmVsICogMyAtIDEpKSA+PiAobiAqIDMgKyAoMiAtIGkpKTtcbiAgICAgICAgICAgICAgICAgICAgY29sb3JbMiAtIGldID0gKGNvbG9yWzIgLSBpXSA8PCAxKSB8ICgoaW5kZXggJiBtYXNrKSA+PiBiaXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IG4gPSBjdGUubGV2ZWw7IG4gPCA4OyBuKyspXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yW2ldID0gKGNvbG9yW2ldIDw8IDEpIHwgKG4gPT09IGN0ZS5sZXZlbCA/IDB4MSA6IDB4MCk7XG4gICAgICAgICAgICBjb2xvcnMucHVzaChjb2xvcik7XG4gICAgICAgICAgICAvL2NvbG9ycy5wdXNoKGN0ZS5ub2RlLmF2Z0NvbG9yKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBCdWlsdCBwYWxldHRlIHdpdGggJHtjb2xvcnMubGVuZ3RofSBjb2xvcnNgKTtcbiAgICAgICAgcmV0dXJuIGNvbG9ycztcbiAgICB9XG4gICAgLy8gUmV0dXJucyBhbiBpbmRleCBmb3IgdGhlIHZpcnR1YWwgb2N0cmVlIGF0IGxldmVsIChOKVxuICAgIC8vIEJ5IGRlc2lnbiB0aGUgb2N0Y3ViZSAoaSkgYXQgbGV2ZWwgKG4gLSAxKSBjb250YWlucyB0aGVcbiAgICAvLyBvY3RjdWJlcyAoOGkgKyBqOyBqIGluIDAtNykgYXQgbGV2ZWwgKG4pXG4gICAgLy9cbiAgICAvLyBJbiBvdGhlciB3b3Jkcywgc2hpZnRpbmcgdGhlIGluZGV4IGF0IGxldmVsIChuKSB0aHJlZSBcbiAgICAvLyBiaXRzIHRvIHRoZSByaWdodCB5aWVsZHMgdGhlIGluZGV4IG9mIHRoZSBjb2xvciBhdCBsZXZlbCAobiAtIDEpXG4gICAgaW5kZXgoY29sb3IpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgZm9yIChsZXQgbiA9IDA7IG4gPCB0aGlzLmxldmVsczsgbisrKSB7XG4gICAgICAgICAgICBjb25zdCBiaXQgPSA3IC0gbjtcbiAgICAgICAgICAgIGxldCBpTGV2ZWwgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBGb3IgZWFjaCBjaGFubmVsLCBnZXQgdGhlIG50aCBiaXQgc3RhcnRpbmcgZnJvbSB0aGUgTVNCXG4gICAgICAgICAgICAgICAgLy8gYW5kIGNvbWJpbmUgdGhlbSBpbiBhIG51bWJlciBpbiByYW5nZSAxLThcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIG91ciBpbmRleCBmb3IgdGhlIGxldmVsIG4gKHJlbGF0aXZlIHRvIGxldmVsIG4tMSlcbiAgICAgICAgICAgICAgICBjb25zdCBtYXNrID0gMHg4MCA+PiBuO1xuICAgICAgICAgICAgICAgIGlMZXZlbCA9IChpTGV2ZWwgPDwgMSkgfCAoKGNvbG9yW2ldICYgbWFzaykgPj4gYml0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNoaWZ0IHRoZSAnZ2xvYmFsJyBpbmRleCBieSAzIGJpdHMgYW5kIGFkZCB0aGUgbmV3IGxldmVsIGluZGV4XG4gICAgICAgICAgICAvLyBUaGUgcmVzdWx0IGlzIHRoZSAnYWJzb2x1dGUnIGluZGV4IG9mIHRoZSBsb3dlc3QgbGV2ZWwgb2N0Y3ViZVxuICAgICAgICAgICAgLy8gdGhlIGNvbG9yIGZpdHMgaW5cbiAgICAgICAgICAgIGluZGV4ID0gKGluZGV4IDw8IDMpIHwgaUxldmVsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gICAgLy8gUmV0dXJucyB0aGUgcHJvcGVydGllcyBmb3IgYW55IGdpdmVuIG5vZGVcbiAgICAvLyBPbmx5IGxlYWYgbm9kZXMgYXJlIGFjdHVhbGx5IHN0b3JlZDsgZm9yIGFueSBvdGhlciBub2RlLFxuICAgIC8vIGEgJ2Zha2UnIG5vZGUgd2l0aCBpdHMgcHJvcGVydGllcyBjYWxjdWxhdGVkIG9uIHRoZSBmbHlcbiAgICAvLyBpcyByZXR1cm5lZFxuICAgIGdldE5vZGUoaW5kZXgsIGxldmVsKSB7XG4gICAgICAgIGlmIChsZXZlbCA9PT0gdGhpcy5sZXZlbHMpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmVlW2luZGV4XTtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCA4OyBqKyspXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNDVEUoOCAqIGluZGV4ICsgaiwgbGV2ZWwgKyAxKSlcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKHRoaXMuZ2V0Tm9kZSg4ICogaW5kZXggKyBqLCBsZXZlbCArIDEpKTtcbiAgICAgICAgY29uc3QgZmFrZU5vZGUgPSBjaGlsZHJlblxuICAgICAgICAgICAgLmZpbHRlcihub2RlID0+IG5vZGUucGl4ZWxDb3VudCA+IDApXG4gICAgICAgICAgICAucmVkdWNlKChhY2MsIG5vZGUpID0+ICh7XG4gICAgICAgICAgICAvL2F2Z0NvbG9yOiBhY2MuYXZnQ29sb3IubWFwKChjaCwgaSkgPT4gY2ggKyBub2RlLmF2Z0NvbG9yW2ldKSxcbiAgICAgICAgICAgIHBpeGVsQ291bnQ6IGFjYy5waXhlbENvdW50ICsgbm9kZS5waXhlbENvdW50XG4gICAgICAgIH0pLCB7IC8qYXZnQ29sb3I6IFswLCAwLCAwXSwqLyBwaXhlbENvdW50OiAwIH0pO1xuICAgICAgICAvLyBQcm9kdWNlIGF2ZXJhZ2UgZnJvbSB0aGUgc3VtIG9mIHRoZSBlaWdodCBjaGlsZCBub2Rlc1xuICAgICAgICAvL2Zha2VOb2RlLmF2Z0NvbG9yID0gZmFrZU5vZGUuYXZnQ29sb3IubWFwKGNoID0+IGNoIC8gOCk7XG4gICAgICAgIC8vaWYgKGZha2VOb2RlLmF2Z0NvbG9yLnNvbWUoY2ggPT4gaXNOYU4oY2gpKSlcbiAgICAgICAgLy8gIGNvbnNvbGUud2FybihgYnJva2VuIGNvbG9yIEAke2luZGV4fSwgbGV2ZWwgJHtsZXZlbH1gKTtcbiAgICAgICAgcmV0dXJuIGZha2VOb2RlO1xuICAgIH1cbiAgICBpc0NURShpbmRleCwgbGV2ZWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3Rlcy5zb21lKGN0ZSA9PiBjdGUuaW5kZXggPT09IGluZGV4ICYmIGN0ZS5sZXZlbCA9PT0gbGV2ZWwpO1xuICAgIH1cbiAgICBtYXJrQ1RFKGluZGV4LCBsZXZlbCwgbm9kZSkge1xuICAgICAgICB0aGlzLmN0ZXMucHVzaCh7IGluZGV4LCBsZXZlbCwgbm9kZSB9KTtcbiAgICB9XG4gICAgdGVzdE5vZGUobkNvbHMsIG5SZXMsIG5QaXgsIG5vZGUpIHtcbiAgICAgICAgLy8gR2V0IHRoZSBudW1iZXIgb2YgY29sb3JzIHlldCB0byBiZSBhc3NpZ25lZFxuICAgICAgICBjb25zdCB1bmFzc2lnbmVkQ29sb3JzID0gbkNvbHMgLSBuUmVzIC0gdGhpcy5jdGVzLmxlbmd0aDtcbiAgICAgICAgLy8gR2V0IHRoZSB0b3RhbCBudW1iZXIgb2YgcGl4ZWxzIHNhbXBsZWQgYW5kIHRoZSBudW1iZXJcbiAgICAgICAgLy8gb2YgcGl4ZWxzIGFzc2lnbmVkIHRvIHNvbWUgQ1RFLCBhbmQgc3VidHJhY3QgdG8gZ2V0XG4gICAgICAgIC8vIHRoZSBudW1iZXIgb2YgcGl4ZWxzIGxlZnQgdG8gYXNzaWduXG4gICAgICAgIGNvbnN0IHVuYXNzaWduZWRQaXhlbHMgPSBuUGl4IC0gdGhpcy5jdGVzXG4gICAgICAgICAgICAubWFwKGN0ZSA9PiBjdGUubm9kZS5waXhlbENvdW50KVxuICAgICAgICAgICAgLnJlZHVjZSgoYWNjLCB2KSA9PiBhY2MgKyB2LCAwKTtcbiAgICAgICAgY29uc3QgdGhyZXNob2xkID0gdW5hc3NpZ25lZFBpeGVscyAvIHVuYXNzaWduZWRDb2xvcnMgKiB0aGlzLms7XG4gICAgICAgIC8vIElmIHRoZSBub2RlIGhhcyBtb3JlIHBpeGVscyB0aGFuIHRoZSBudW1iZXIgb2YgcGl4ZWxzIGxlZnRcbiAgICAgICAgLy8gdG8gYXNzaWduIGRpdmlkZWQgYnkgdGhlIG51bWJlciBvZiBhdmFpbGFibGUgY29sb3JzLCB0aGVuXG4gICAgICAgIC8vIGl0IHNob3VsZCBnZXQgYSBjb2xvciBpbiB0aGUgcGFsZXR0ZVxuICAgICAgICByZXR1cm4gbm9kZS5waXhlbENvdW50ID4gdGhyZXNob2xkO1xuICAgIH1cbiAgICBnZXQgbm9uUmVzZXJ2ZWRDVEVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdGVzLmZpbHRlcihjdGUgPT4gY3RlLmxldmVsICE9PSB0aGlzLnJlc2VydmVkTGV2ZWwpLmxlbmd0aDtcbiAgICB9XG4gICAgZ2VuZXJhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmdlbmVyYXRlZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBwYWxldHRlIGhhcyBhbHJlYWR5IGJlZW4gZ2VuZXJhdGVkJyk7XG4gICAgICAgIHRoaXMuZ2VuZXJhdGVkID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgcmVzZXJ2ZWQgPSB0aGlzLnJlc2VydmVkTGV2ZWwgPCAwID8gMCA6IE1hdGgucG93KDgsIHRoaXMucmVzZXJ2ZWRMZXZlbCk7XG4gICAgICAgIGNvbnN0IHNhbXBsZWQgPSB0aGlzLmdldE5vZGUoMCwgMCkucGl4ZWxDb3VudDtcbiAgICAgICAgbGV0IGxldmVsO1xuICAgICAgICBsZXQgbGFzdEl0ZXJhdGlvbkNURXMgPSAwO1xuICAgICAgICBsZXQgc3R1Y2tDb3VudGVyID0gMDtcbiAgICAgICAgLy8gUmVwZWF0IHVudGlsIHRoZSBwYWxldHRlIGlzIGZ1bGwhXG4gICAgICAgIHdoaWxlICh0aGlzLm5Db2xvcnMgLSByZXNlcnZlZCAtIHRoaXMubm9uUmVzZXJ2ZWRDVEVzID4gMCkge1xuICAgICAgICAgICAgbGV2ZWwgPSB0aGlzLmxldmVsczsgLy8gU3RhcnQgYXQgbGVhZiBub2RlIGxldmVsXG4gICAgICAgICAgICAvLyBQcnVuZSB1cCB1bnRpbCB0aGUgc3BlY2lmaWVkIGxldmVsXG4gICAgICAgICAgICAvLyBBbGwgY29sb3JzIGluIHRoYXQgbGV2ZWwgYXJlIHRoZW4gcmVzZXJ2ZWRcbiAgICAgICAgICAgIHdoaWxlIChsZXZlbCA+IHRoaXMucmVzZXJ2ZWRMZXZlbCAmJiBsZXZlbCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlcyA9IE1hdGgucG93KDgsIGxldmVsKTtcbiAgICAgICAgICAgICAgICAvLyBJdGVyYXRlIHRocm91Z2ggYWxsIG5vZGVzIGluIHRoZSBsZXZlbFxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBub2RlID0gdGhpcy5nZXROb2RlKGksIGxldmVsKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIG5vZGUgaXMgbm90IHlldCBhIENURSwgYW5kIGhhcyBlbm91Z2ggcGl4ZWxzIHRvIGJlXG4gICAgICAgICAgICAgICAgICAgIC8vIG9uZSwgbWFrZSBpdCBhIENURVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNDVEUoaSwgbGV2ZWwpICYmIHRoaXMudGVzdE5vZGUodGhpcy5uQ29sb3JzLCByZXNlcnZlZCwgc2FtcGxlZCwgbm9kZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcmtDVEUoaSwgbGV2ZWwsIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBFdmVyeSA4dGggbm9kZSwgY2hlY2sgdGhlIGxhc3QgOCBub2Rlc1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBhbnkgbm9kZXMgYXJlIGEgQ1RFLCBtYWtlIHRoZSBwYXJlbnQgYSBDVEUgVU5MRVNTIGFsbCA4IG5vZGVzIGFyZSBDVEVzXG4gICAgICAgICAgICAgICAgICAgIGlmIChpICUgOCA9PT0gNykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGN0ZXMgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IGkgLSA3OyBqIDw9IGk7IGorKylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0NURShqLCBsZXZlbCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0ZXMrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdGVzID4gMCAmJiBjdGVzIDwgOCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlQYXJlbnQgPSBpID4+IDM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzQ1RFKGlQYXJlbnQsIGxldmVsIC0gMSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWFya0NURShpUGFyZW50LCBsZXZlbCAtIDEsIHRoaXMuZ2V0Tm9kZShpUGFyZW50LCBsZXZlbCAtIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBTdG9wIGlmIHRoZSBwYWxldHRlIGlzIGZ1bGxcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubkNvbG9ycyAtIHJlc2VydmVkIC0gdGhpcy5ub25SZXNlcnZlZENURXMgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLndhcm4oYFJhbiBvdXQgb2YgY29sb3JzISBBdCBub2RlICR7aX0sIGxldmVsICR7bGV2ZWx9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTdG9wIGlmIHRoZSBwYWxldHRlIGlzIGZ1bGxcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5uQ29sb3JzIC0gcmVzZXJ2ZWQgLSB0aGlzLm5vblJlc2VydmVkQ1RFcyA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS53YXJuKGBSYW4gb3V0IG9mIGNvbG9ycyEgQXQgbGV2ZWwgJHtsZXZlbH1gKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldmVsLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKGAke3RoaXMuY3Rlcy5sZW5ndGh9IENURXMsICR7dGhpcy5jdGVzLmxlbmd0aCAtIHRoaXMubm9uUmVzZXJ2ZWRDVEVzfSByZXNlcnZlZGApO1xuICAgICAgICAgICAgaWYgKHRoaXMuY3Rlcy5sZW5ndGggPT09IGxhc3RJdGVyYXRpb25DVEVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5rID0gdGhpcy5rIC8gMjtcbiAgICAgICAgICAgICAgICBzdHVja0NvdW50ZXIrKztcbiAgICAgICAgICAgICAgICBpZiAoc3R1Y2tDb3VudGVyID49IDUpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdEl0ZXJhdGlvbkNURXMgPSB0aGlzLmN0ZXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpbmFsbHksIGhhbmRsZSByZXNlcnZlZCBjb2xvcnNcbiAgICAgICAgaWYgKHRoaXMucmVzZXJ2ZWRMZXZlbCA+PSAwKSB7XG4gICAgICAgICAgICBsZXZlbCA9IHRoaXMucmVzZXJ2ZWRMZXZlbDtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVzID0gTWF0aC5wb3coOCwgbGV2ZWwpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuZ2V0Tm9kZShpLCBsZXZlbCk7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIG5vZGUgaXMgbm90IHlldCBhIENURSwgbWFrZSBpdCBvbmVcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNDVEUoaSwgbGV2ZWwpKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcmtDVEUoaSwgbGV2ZWwsIG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlUGFsZXR0ZShvcHRzLCBpbWcpIHtcbiAgICBjb25zdCBvY3RyZWUgPSBuZXcgUGFsZXR0ZUdlbmVyYXRvcihvcHRzKTtcbiAgICBjb25zdCBzaXplID0gaW1nLndpZHRoICogaW1nLmhlaWdodCAqIDQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpICs9IDQpIHtcbiAgICAgICAgY29uc3QgeSA9IH5+KGkgLyA0IC8gaW1nLndpZHRoKTtcbiAgICAgICAgY29uc3QgeCA9IH5+KGkgLyA0ICUgaW1nLndpZHRoKTtcbiAgICAgICAgaWYgKHggJSBTVUJTQU1QTElORyA9PT0gMCAmJiB5ICUgU1VCU0FNUExJTkcgPT09IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbG9yID0gQXJyYXkuZnJvbShpbWcuZGF0YS5zbGljZShpLCBpICsgNCkpO1xuICAgICAgICAgICAgb2N0cmVlLmFkZENvbG9yKGNvbG9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjb2xvcnMgPSBvY3RyZWUuZ2V0UGFsZXR0ZSgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6ICdfX0dFTkVSQVRFRF9fJyxcbiAgICAgICAgdHlwZTogUGFsZXR0ZVR5cGUuUE90aGVyLFxuICAgICAgICB1c2VBbHBoYTogZmFsc2UsXG4gICAgICAgIGRhdGE6IGNvbG9yc1xuICAgIH07XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/paletteGen/PaletteGenerator.ts\n");

/***/ }),

/***/ "./src/paletteGen/getAutoPalette.ts":
/*!******************************************!*\
  !*** ./src/paletteGen/getAutoPalette.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getAutoPalette\": () => (/* binding */ getAutoPalette),\n/* harmony export */   \"clearPaletteCache\": () => (/* binding */ clearPaletteCache)\n/* harmony export */ });\n/* harmony import */ var _PaletteGenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PaletteGenerator */ \"./src/paletteGen/PaletteGenerator.ts\");\n\nconst paletteCache = [];\nfunction getAutoPalette(template, imageData) {\n    const key = `AUTO_${template.data[0][0]}_${template.data[1][2]}`;\n    const cached = paletteCache.find(entry => entry.key === key);\n    if (cached)\n        return cached.palette;\n    else {\n        const options = {\n            numColors: template.data[0][0],\n            reservedLevel: template.data[0][1],\n            levels: template.data[0][2],\n            inclThresholdCoeff: template.data[1][0]\n        };\n        // Replace the 'template' auto palette with the appropriate\n        // palette generated from the image\n        const palette = (0,_PaletteGenerator__WEBPACK_IMPORTED_MODULE_0__.generatePalette)(options, imageData);\n        paletteCache.push({ key, palette });\n        return palette;\n    }\n}\nfunction clearPaletteCache() {\n    paletteCache.splice(0);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbWFnZWJpdGRlcHRoLy4vc3JjL3BhbGV0dGVHZW4vZ2V0QXV0b1BhbGV0dGUudHM/N2MwMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBcUQ7QUFDckQ7QUFDTztBQUNQLHdCQUF3QixvQkFBb0IsR0FBRyxvQkFBb0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtFQUFlO0FBQ3ZDLDJCQUEyQixlQUFlO0FBQzFDO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSIsImZpbGUiOiIuL3NyYy9wYWxldHRlR2VuL2dldEF1dG9QYWxldHRlLnRzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2VuZXJhdGVQYWxldHRlIH0gZnJvbSAnLi9QYWxldHRlR2VuZXJhdG9yJztcbmNvbnN0IHBhbGV0dGVDYWNoZSA9IFtdO1xuZXhwb3J0IGZ1bmN0aW9uIGdldEF1dG9QYWxldHRlKHRlbXBsYXRlLCBpbWFnZURhdGEpIHtcbiAgICBjb25zdCBrZXkgPSBgQVVUT18ke3RlbXBsYXRlLmRhdGFbMF1bMF19XyR7dGVtcGxhdGUuZGF0YVsxXVsyXX1gO1xuICAgIGNvbnN0IGNhY2hlZCA9IHBhbGV0dGVDYWNoZS5maW5kKGVudHJ5ID0+IGVudHJ5LmtleSA9PT0ga2V5KTtcbiAgICBpZiAoY2FjaGVkKVxuICAgICAgICByZXR1cm4gY2FjaGVkLnBhbGV0dGU7XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBudW1Db2xvcnM6IHRlbXBsYXRlLmRhdGFbMF1bMF0sXG4gICAgICAgICAgICByZXNlcnZlZExldmVsOiB0ZW1wbGF0ZS5kYXRhWzBdWzFdLFxuICAgICAgICAgICAgbGV2ZWxzOiB0ZW1wbGF0ZS5kYXRhWzBdWzJdLFxuICAgICAgICAgICAgaW5jbFRocmVzaG9sZENvZWZmOiB0ZW1wbGF0ZS5kYXRhWzFdWzBdXG4gICAgICAgIH07XG4gICAgICAgIC8vIFJlcGxhY2UgdGhlICd0ZW1wbGF0ZScgYXV0byBwYWxldHRlIHdpdGggdGhlIGFwcHJvcHJpYXRlXG4gICAgICAgIC8vIHBhbGV0dGUgZ2VuZXJhdGVkIGZyb20gdGhlIGltYWdlXG4gICAgICAgIGNvbnN0IHBhbGV0dGUgPSBnZW5lcmF0ZVBhbGV0dGUob3B0aW9ucywgaW1hZ2VEYXRhKTtcbiAgICAgICAgcGFsZXR0ZUNhY2hlLnB1c2goeyBrZXksIHBhbGV0dGUgfSk7XG4gICAgICAgIHJldHVybiBwYWxldHRlO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBjbGVhclBhbGV0dGVDYWNoZSgpIHtcbiAgICBwYWxldHRlQ2FjaGUuc3BsaWNlKDApO1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/paletteGen/getAutoPalette.ts\n");

/***/ }),

/***/ "./src/process/Process.ts":
/*!********************************!*\
  !*** ./src/process/Process.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getProcessById\": () => (/* binding */ getProcessById)\n/* harmony export */ });\n/* harmony import */ var _processes_Basic__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./processes/Basic */ \"./src/process/processes/Basic.ts\");\n/* harmony import */ var _processes_BayerLike__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./processes/BayerLike */ \"./src/process/processes/BayerLike.ts\");\n/* harmony import */ var _processes_FloydSteinberg__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./processes/FloydSteinberg */ \"./src/process/processes/FloydSteinberg.ts\");\n/* harmony import */ var _processes_Weighted__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./processes/Weighted */ \"./src/process/processes/Weighted.ts\");\n\n\n\n\nconst getProcessById = (id) => {\n    switch (id) {\n        case _processes_Basic__WEBPACK_IMPORTED_MODULE_0__.default.id:\n            return _processes_Basic__WEBPACK_IMPORTED_MODULE_0__.default;\n        case _processes_FloydSteinberg__WEBPACK_IMPORTED_MODULE_2__.default.id:\n            return _processes_FloydSteinberg__WEBPACK_IMPORTED_MODULE_2__.default;\n        case _processes_BayerLike__WEBPACK_IMPORTED_MODULE_1__.BayerLikeFast.id:\n            return _processes_BayerLike__WEBPACK_IMPORTED_MODULE_1__.BayerLikeFast;\n        case _processes_BayerLike__WEBPACK_IMPORTED_MODULE_1__.BayerLike.id:\n            return _processes_BayerLike__WEBPACK_IMPORTED_MODULE_1__.BayerLike;\n        case _processes_Weighted__WEBPACK_IMPORTED_MODULE_3__.default.id:\n            return _processes_Weighted__WEBPACK_IMPORTED_MODULE_3__.default;\n        default:\n            return null;\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbWFnZWJpdGRlcHRoLy4vc3JjL3Byb2Nlc3MvUHJvY2Vzcy50cz9hMGQ3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQXNDO0FBQzJCO0FBQ1Q7QUFDSjtBQUM3QztBQUNQO0FBQ0EsYUFBYSx3REFBUTtBQUNyQixtQkFBbUIscURBQUs7QUFDeEIsYUFBYSxpRUFBaUI7QUFDOUIsbUJBQW1CLDhEQUFjO0FBQ2pDLGFBQWEsa0VBQWdCO0FBQzdCLG1CQUFtQiwrREFBYTtBQUNoQyxhQUFhLDhEQUFZO0FBQ3pCLG1CQUFtQiwyREFBUztBQUM1QixhQUFhLDJEQUFtQjtBQUNoQyxtQkFBbUIsd0RBQWdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vc3JjL3Byb2Nlc3MvUHJvY2Vzcy50cy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBCYXNpYyBmcm9tICcuL3Byb2Nlc3Nlcy9CYXNpYyc7XG5pbXBvcnQgeyBCYXllckxpa2UsIEJheWVyTGlrZUZhc3QgfSBmcm9tICcuL3Byb2Nlc3Nlcy9CYXllckxpa2UnO1xuaW1wb3J0IEZsb3lkU3RlaW5iZXJnIGZyb20gJy4vcHJvY2Vzc2VzL0Zsb3lkU3RlaW5iZXJnJztcbmltcG9ydCBXZWlnaHRlZENvbG9yTWFwIGZyb20gJy4vcHJvY2Vzc2VzL1dlaWdodGVkJztcbmV4cG9ydCBjb25zdCBnZXRQcm9jZXNzQnlJZCA9IChpZCkgPT4ge1xuICAgIHN3aXRjaCAoaWQpIHtcbiAgICAgICAgY2FzZSBCYXNpYy5pZDpcbiAgICAgICAgICAgIHJldHVybiBCYXNpYztcbiAgICAgICAgY2FzZSBGbG95ZFN0ZWluYmVyZy5pZDpcbiAgICAgICAgICAgIHJldHVybiBGbG95ZFN0ZWluYmVyZztcbiAgICAgICAgY2FzZSBCYXllckxpa2VGYXN0LmlkOlxuICAgICAgICAgICAgcmV0dXJuIEJheWVyTGlrZUZhc3Q7XG4gICAgICAgIGNhc2UgQmF5ZXJMaWtlLmlkOlxuICAgICAgICAgICAgcmV0dXJuIEJheWVyTGlrZTtcbiAgICAgICAgY2FzZSBXZWlnaHRlZENvbG9yTWFwLmlkOlxuICAgICAgICAgICAgcmV0dXJuIFdlaWdodGVkQ29sb3JNYXA7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/process/Process.ts\n");

/***/ }),

/***/ "./src/process/processes/Basic.ts":
/*!****************************************!*\
  !*** ./src/process/processes/Basic.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _palette_paletteMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../palette/paletteMap */ \"./src/palette/paletteMap.ts\");\n\nconst processBasic = (dataIn, palette, distFn, features, cbProgress) => {\n    const line = dataIn.width * 4;\n    const size = dataIn.width * dataIn.height * 4;\n    for (let i = 0; i < size; i += 4) {\n        const color = Array.from(dataIn.data.slice(i, i + 4));\n        const mapped = (0,_palette_paletteMap__WEBPACK_IMPORTED_MODULE_0__.paletteMap)(color, palette, distFn);\n        for (let j = 0; j < 3; j++)\n            dataIn.data[i + j] = mapped[j];\n        if (i % (8 * line) === 0 && cbProgress)\n            cbProgress(i, size, dataIn);\n    }\n    return dataIn;\n};\nconst Basic = {\n    id: 'ProcBasic',\n    name: 'Basic (no dithering)',\n    procFn: processBasic,\n    maxAllowedPaletteSize: 65536,\n    supports: {\n        threads: false,\n        gamma: false // Unsupported\n    },\n    complexity: (n) => n\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Basic);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbWFnZWJpdGRlcHRoLy4vc3JjL3Byb2Nlc3MvcHJvY2Vzc2VzL0Jhc2ljLnRzPzc2YjIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQSx1QkFBdUIsK0RBQVU7QUFDakMsdUJBQXVCLE9BQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsaUVBQWUsS0FBSyxFQUFDIiwiZmlsZSI6Ii4vc3JjL3Byb2Nlc3MvcHJvY2Vzc2VzL0Jhc2ljLnRzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcGFsZXR0ZU1hcCB9IGZyb20gJy4uLy4uL3BhbGV0dGUvcGFsZXR0ZU1hcCc7XG5jb25zdCBwcm9jZXNzQmFzaWMgPSAoZGF0YUluLCBwYWxldHRlLCBkaXN0Rm4sIGZlYXR1cmVzLCBjYlByb2dyZXNzKSA9PiB7XG4gICAgY29uc3QgbGluZSA9IGRhdGFJbi53aWR0aCAqIDQ7XG4gICAgY29uc3Qgc2l6ZSA9IGRhdGFJbi53aWR0aCAqIGRhdGFJbi5oZWlnaHQgKiA0O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSArPSA0KSB7XG4gICAgICAgIGNvbnN0IGNvbG9yID0gQXJyYXkuZnJvbShkYXRhSW4uZGF0YS5zbGljZShpLCBpICsgNCkpO1xuICAgICAgICBjb25zdCBtYXBwZWQgPSBwYWxldHRlTWFwKGNvbG9yLCBwYWxldHRlLCBkaXN0Rm4pO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDM7IGorKylcbiAgICAgICAgICAgIGRhdGFJbi5kYXRhW2kgKyBqXSA9IG1hcHBlZFtqXTtcbiAgICAgICAgaWYgKGkgJSAoOCAqIGxpbmUpID09PSAwICYmIGNiUHJvZ3Jlc3MpXG4gICAgICAgICAgICBjYlByb2dyZXNzKGksIHNpemUsIGRhdGFJbik7XG4gICAgfVxuICAgIHJldHVybiBkYXRhSW47XG59O1xuY29uc3QgQmFzaWMgPSB7XG4gICAgaWQ6ICdQcm9jQmFzaWMnLFxuICAgIG5hbWU6ICdCYXNpYyAobm8gZGl0aGVyaW5nKScsXG4gICAgcHJvY0ZuOiBwcm9jZXNzQmFzaWMsXG4gICAgbWF4QWxsb3dlZFBhbGV0dGVTaXplOiA2NTUzNixcbiAgICBzdXBwb3J0czoge1xuICAgICAgICB0aHJlYWRzOiBmYWxzZSxcbiAgICAgICAgZ2FtbWE6IGZhbHNlIC8vIFVuc3VwcG9ydGVkXG4gICAgfSxcbiAgICBjb21wbGV4aXR5OiAobikgPT4gblxufTtcbmV4cG9ydCBkZWZhdWx0IEJhc2ljO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/process/processes/Basic.ts\n");

/***/ }),

/***/ "./src/process/processes/BayerLike.ts":
/*!********************************************!*\
  !*** ./src/process/processes/BayerLike.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BayerLikeFast\": () => (/* binding */ BayerLikeFast),\n/* harmony export */   \"BayerLike\": () => (/* binding */ BayerLike)\n/* harmony export */ });\n/* harmony import */ var _palette_PaletteGroups__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../palette/PaletteGroups */ \"./src/palette/PaletteGroups.ts\");\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/utils */ \"./src/utils/utils.ts\");\n\n\n// 8x8 threshold map\nconst threshold = [\n    0, 48, 12, 60, 3, 51, 15, 63,\n    32, 16, 44, 28, 35, 19, 47, 31,\n    8, 56, 4, 52, 11, 59, 7, 55,\n    40, 24, 36, 20, 43, 27, 39, 23,\n    2, 50, 14, 62, 1, 49, 13, 61,\n    34, 18, 46, 30, 33, 17, 45, 29,\n    10, 58, 6, 54, 9, 57, 5, 53,\n    42, 26, 38, 22, 41, 25, 37, 21\n].map(v => v / 64.0);\n// Weight function that determines the error for a given color mix\n// and target color, penalizing mixes where the components differ\n// too much\nfunction evalMixError(target, mix, compDist, rmh, distFn) {\n    return distFn(target, mix) + compDist * ((rmh < 0 ? -rmh : rmh) + 0.5);\n}\nfunction processBayer(fast = true) {\n    return (dataIn, palette, distFn, features, cbProgress) => {\n        // Expand an RGB palette into a fixed-color palette\n        // in order for the algorithm to work\n        if (palette.type === _palette_PaletteGroups__WEBPACK_IMPORTED_MODULE_0__.default.PRGB)\n            palette = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.expandRGBPalette)(palette);\n        const size = dataIn.width * dataIn.height * 4;\n        const line = dataIn.width * 4;\n        // Pre-calculate (weighted) distance between all permutations of two colors\n        // in the given palette, this saves us a few million distance calculations\n        const paletteDistances = {};\n        for (let i1 = 0; i1 < palette.data.length; i1++)\n            for (let i2 = i1; i2 < palette.data.length; i2++) {\n                const index = i1 * palette.data.length + i2; // A unique index\n                paletteDistances[index] = distFn(palette.data[i1], palette.data[i2]) * 0.1;\n            }\n        // Declare all heap-allocated variables to prevent unnecessary garbage collection\n        const mix = [0, 0, 0];\n        let color, cl1, cl2;\n        let bestMix;\n        for (let i = 0; i < size; i += 4) {\n            color = Array.from(dataIn.data.slice(i, i + 4));\n            const x = (i % line) / 4;\n            const y = ~~(i / line);\n            const mapValue = threshold[(x % 8) + (y % 8) * 8];\n            bestMix = { color1: [0, 0, 0], color2: color, ratio: 0.33 };\n            let minError = Number.MAX_VALUE;\n            for (let i1 = 0; i1 < palette.data.length; i1++)\n                for (let i2 = i1; i2 < palette.data.length; i2++) {\n                    cl1 = palette.data[i1];\n                    cl2 = palette.data[i2];\n                    if (fast) {\n                        // Fast approximation of the 'proper' algorithm\n                        let ratio = 32;\n                        if (i1 !== i2) {\n                            ratio = ((cl1[0] !== cl2[0] ? 299 * 64 * (color[0] - cl1[0]) / (cl2[0] - cl1[0]) : 0)\n                                + (cl1[1] !== cl2[1] ? 587 * 64 * (color[1] - cl1[1]) / (cl2[1] - cl1[1]) : 0)\n                                + (cl1[2] !== cl2[2] ? 114 * 64 * (color[2] - cl1[2]) / (cl2[2] - cl1[2]) : 0))\n                                / ((cl1[0] !== cl2[0] ? 299 : 0) + (cl1[1] !== cl2[1] ? 587 : 0) + (cl1[2] !== cl2[2] ? 114 : 0));\n                            if (ratio < 0)\n                                ratio = 0;\n                            else if (ratio > 63)\n                                ratio = 63;\n                            ratio = ~~ratio; // Fast floor (to integer)\n                        }\n                        const r64 = ratio / 64;\n                        for (let j = 0; j < 3; j++)\n                            mix[j] = cl1[j] + r64 * (cl2[j] - cl1[j]);\n                        // Get the distance between components we calculated earlier\n                        const dist = paletteDistances[i1 * palette.data.length + i2];\n                        const error = evalMixError(color, mix, dist, r64 - 0.5, distFn);\n                        if (error < minError) {\n                            minError = error;\n                            bestMix.color1 = cl1;\n                            bestMix.color2 = cl2;\n                            bestMix.ratio = r64;\n                        }\n                    }\n                    else {\n                        // Slow version using the more thorough iterative algorithm\n                        // This looks somewhat better, but is *much* slower\n                        for (let ratio = 0; ratio < 64; ratio++) {\n                            if (i1 === i2 && ratio > 0)\n                                break;\n                            const r64 = ratio / 64;\n                            for (let j = 0; j < 3; j++)\n                                mix[j] = cl1[j] + r64 * (cl2[j] - cl1[j]);\n                            // Get the distance between components we calculated earlier\n                            const dist = paletteDistances[i1 * palette.data.length + i2];\n                            const error = evalMixError(color, mix, dist, r64 - 0.5, distFn);\n                            if (error < minError) {\n                                minError = error;\n                                bestMix.color1 = cl1;\n                                bestMix.color2 = cl2;\n                                bestMix.ratio = r64;\n                            }\n                        }\n                    }\n                }\n            for (let j = 0; j < 3; j++)\n                dataIn.data[i + j] = mapValue < bestMix.ratio ?\n                    bestMix.color2[j] :\n                    bestMix.color1[j];\n            if (i % (line * 4) === 0 && cbProgress)\n                cbProgress(i, size, dataIn);\n        }\n        return dataIn;\n    };\n}\nconst BayerLikeFast = {\n    id: 'ProcBayerLikeFast',\n    name: 'Ordered (Bayer-like) – Fast',\n    procFn: processBayer(),\n    maxAllowedPaletteSize: 192,\n    supports: {\n        threads: true,\n        gamma: false // Not implemented\n    },\n    complexity: (n) => (n * n / 2) // O(n²/2)\n};\nconst BayerLike = {\n    id: 'ProcBayerLikeThorough',\n    name: 'Ordered (Bayer-like) – High Quality',\n    procFn: processBayer(false),\n    maxAllowedPaletteSize: 24,\n    supports: {\n        threads: true,\n        gamma: false // Not implemented\n    },\n    complexity: (n) => (n * n * 32) // O(n²/2 * 64)\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbWFnZWJpdGRlcHRoLy4vc3JjL3Byb2Nlc3MvcHJvY2Vzc2VzL0JheWVyTGlrZS50cz9kMjIxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBc0Q7QUFDRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsZ0VBQWdCO0FBQzdDLHNCQUFzQiw4REFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwwQkFBMEI7QUFDbEQsNkJBQTZCLDBCQUEwQjtBQUN2RCw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFVBQVU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSw0QkFBNEIsMEJBQTBCO0FBQ3RELGlDQUFpQywwQkFBMEI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0EsdUNBQXVDLE9BQU87QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxZQUFZO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLE9BQU87QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBIiwiZmlsZSI6Ii4vc3JjL3Byb2Nlc3MvcHJvY2Vzc2VzL0JheWVyTGlrZS50cy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBQYWxldHRlVHlwZSBmcm9tICcuLi8uLi9wYWxldHRlL1BhbGV0dGVHcm91cHMnO1xuaW1wb3J0IHsgZXhwYW5kUkdCUGFsZXR0ZSB9IGZyb20gJy4uLy4uL3V0aWxzL3V0aWxzJztcbi8vIDh4OCB0aHJlc2hvbGQgbWFwXG5jb25zdCB0aHJlc2hvbGQgPSBbXG4gICAgMCwgNDgsIDEyLCA2MCwgMywgNTEsIDE1LCA2MyxcbiAgICAzMiwgMTYsIDQ0LCAyOCwgMzUsIDE5LCA0NywgMzEsXG4gICAgOCwgNTYsIDQsIDUyLCAxMSwgNTksIDcsIDU1LFxuICAgIDQwLCAyNCwgMzYsIDIwLCA0MywgMjcsIDM5LCAyMyxcbiAgICAyLCA1MCwgMTQsIDYyLCAxLCA0OSwgMTMsIDYxLFxuICAgIDM0LCAxOCwgNDYsIDMwLCAzMywgMTcsIDQ1LCAyOSxcbiAgICAxMCwgNTgsIDYsIDU0LCA5LCA1NywgNSwgNTMsXG4gICAgNDIsIDI2LCAzOCwgMjIsIDQxLCAyNSwgMzcsIDIxXG5dLm1hcCh2ID0+IHYgLyA2NC4wKTtcbi8vIFdlaWdodCBmdW5jdGlvbiB0aGF0IGRldGVybWluZXMgdGhlIGVycm9yIGZvciBhIGdpdmVuIGNvbG9yIG1peFxuLy8gYW5kIHRhcmdldCBjb2xvciwgcGVuYWxpemluZyBtaXhlcyB3aGVyZSB0aGUgY29tcG9uZW50cyBkaWZmZXJcbi8vIHRvbyBtdWNoXG5mdW5jdGlvbiBldmFsTWl4RXJyb3IodGFyZ2V0LCBtaXgsIGNvbXBEaXN0LCBybWgsIGRpc3RGbikge1xuICAgIHJldHVybiBkaXN0Rm4odGFyZ2V0LCBtaXgpICsgY29tcERpc3QgKiAoKHJtaCA8IDAgPyAtcm1oIDogcm1oKSArIDAuNSk7XG59XG5mdW5jdGlvbiBwcm9jZXNzQmF5ZXIoZmFzdCA9IHRydWUpIHtcbiAgICByZXR1cm4gKGRhdGFJbiwgcGFsZXR0ZSwgZGlzdEZuLCBmZWF0dXJlcywgY2JQcm9ncmVzcykgPT4ge1xuICAgICAgICAvLyBFeHBhbmQgYW4gUkdCIHBhbGV0dGUgaW50byBhIGZpeGVkLWNvbG9yIHBhbGV0dGVcbiAgICAgICAgLy8gaW4gb3JkZXIgZm9yIHRoZSBhbGdvcml0aG0gdG8gd29ya1xuICAgICAgICBpZiAocGFsZXR0ZS50eXBlID09PSBQYWxldHRlVHlwZS5QUkdCKVxuICAgICAgICAgICAgcGFsZXR0ZSA9IGV4cGFuZFJHQlBhbGV0dGUocGFsZXR0ZSk7XG4gICAgICAgIGNvbnN0IHNpemUgPSBkYXRhSW4ud2lkdGggKiBkYXRhSW4uaGVpZ2h0ICogNDtcbiAgICAgICAgY29uc3QgbGluZSA9IGRhdGFJbi53aWR0aCAqIDQ7XG4gICAgICAgIC8vIFByZS1jYWxjdWxhdGUgKHdlaWdodGVkKSBkaXN0YW5jZSBiZXR3ZWVuIGFsbCBwZXJtdXRhdGlvbnMgb2YgdHdvIGNvbG9yc1xuICAgICAgICAvLyBpbiB0aGUgZ2l2ZW4gcGFsZXR0ZSwgdGhpcyBzYXZlcyB1cyBhIGZldyBtaWxsaW9uIGRpc3RhbmNlIGNhbGN1bGF0aW9uc1xuICAgICAgICBjb25zdCBwYWxldHRlRGlzdGFuY2VzID0ge307XG4gICAgICAgIGZvciAobGV0IGkxID0gMDsgaTEgPCBwYWxldHRlLmRhdGEubGVuZ3RoOyBpMSsrKVxuICAgICAgICAgICAgZm9yIChsZXQgaTIgPSBpMTsgaTIgPCBwYWxldHRlLmRhdGEubGVuZ3RoOyBpMisrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBpMSAqIHBhbGV0dGUuZGF0YS5sZW5ndGggKyBpMjsgLy8gQSB1bmlxdWUgaW5kZXhcbiAgICAgICAgICAgICAgICBwYWxldHRlRGlzdGFuY2VzW2luZGV4XSA9IGRpc3RGbihwYWxldHRlLmRhdGFbaTFdLCBwYWxldHRlLmRhdGFbaTJdKSAqIDAuMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgLy8gRGVjbGFyZSBhbGwgaGVhcC1hbGxvY2F0ZWQgdmFyaWFibGVzIHRvIHByZXZlbnQgdW5uZWNlc3NhcnkgZ2FyYmFnZSBjb2xsZWN0aW9uXG4gICAgICAgIGNvbnN0IG1peCA9IFswLCAwLCAwXTtcbiAgICAgICAgbGV0IGNvbG9yLCBjbDEsIGNsMjtcbiAgICAgICAgbGV0IGJlc3RNaXg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSArPSA0KSB7XG4gICAgICAgICAgICBjb2xvciA9IEFycmF5LmZyb20oZGF0YUluLmRhdGEuc2xpY2UoaSwgaSArIDQpKTtcbiAgICAgICAgICAgIGNvbnN0IHggPSAoaSAlIGxpbmUpIC8gNDtcbiAgICAgICAgICAgIGNvbnN0IHkgPSB+fihpIC8gbGluZSk7XG4gICAgICAgICAgICBjb25zdCBtYXBWYWx1ZSA9IHRocmVzaG9sZFsoeCAlIDgpICsgKHkgJSA4KSAqIDhdO1xuICAgICAgICAgICAgYmVzdE1peCA9IHsgY29sb3IxOiBbMCwgMCwgMF0sIGNvbG9yMjogY29sb3IsIHJhdGlvOiAwLjMzIH07XG4gICAgICAgICAgICBsZXQgbWluRXJyb3IgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICAgICAgZm9yIChsZXQgaTEgPSAwOyBpMSA8IHBhbGV0dGUuZGF0YS5sZW5ndGg7IGkxKyspXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaTIgPSBpMTsgaTIgPCBwYWxldHRlLmRhdGEubGVuZ3RoOyBpMisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsMSA9IHBhbGV0dGUuZGF0YVtpMV07XG4gICAgICAgICAgICAgICAgICAgIGNsMiA9IHBhbGV0dGUuZGF0YVtpMl07XG4gICAgICAgICAgICAgICAgICAgIGlmIChmYXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGYXN0IGFwcHJveGltYXRpb24gb2YgdGhlICdwcm9wZXInIGFsZ29yaXRobVxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJhdGlvID0gMzI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaTEgIT09IGkyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmF0aW8gPSAoKGNsMVswXSAhPT0gY2wyWzBdID8gMjk5ICogNjQgKiAoY29sb3JbMF0gLSBjbDFbMF0pIC8gKGNsMlswXSAtIGNsMVswXSkgOiAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArIChjbDFbMV0gIT09IGNsMlsxXSA/IDU4NyAqIDY0ICogKGNvbG9yWzFdIC0gY2wxWzFdKSAvIChjbDJbMV0gLSBjbDFbMV0pIDogMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyAoY2wxWzJdICE9PSBjbDJbMl0gPyAxMTQgKiA2NCAqIChjb2xvclsyXSAtIGNsMVsyXSkgLyAoY2wyWzJdIC0gY2wxWzJdKSA6IDApKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvICgoY2wxWzBdICE9PSBjbDJbMF0gPyAyOTkgOiAwKSArIChjbDFbMV0gIT09IGNsMlsxXSA/IDU4NyA6IDApICsgKGNsMVsyXSAhPT0gY2wyWzJdID8gMTE0IDogMCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyYXRpbyA8IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhdGlvID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyYXRpbyA+IDYzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYXRpbyA9IDYzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhdGlvID0gfn5yYXRpbzsgLy8gRmFzdCBmbG9vciAodG8gaW50ZWdlcilcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHI2NCA9IHJhdGlvIC8gNjQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDM7IGorKylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaXhbal0gPSBjbDFbal0gKyByNjQgKiAoY2wyW2pdIC0gY2wxW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgZGlzdGFuY2UgYmV0d2VlbiBjb21wb25lbnRzIHdlIGNhbGN1bGF0ZWQgZWFybGllclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlzdCA9IHBhbGV0dGVEaXN0YW5jZXNbaTEgKiBwYWxldHRlLmRhdGEubGVuZ3RoICsgaTJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBldmFsTWl4RXJyb3IoY29sb3IsIG1peCwgZGlzdCwgcjY0IC0gMC41LCBkaXN0Rm4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yIDwgbWluRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5FcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNaXguY29sb3IxID0gY2wxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNaXguY29sb3IyID0gY2wyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNaXgucmF0aW8gPSByNjQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTbG93IHZlcnNpb24gdXNpbmcgdGhlIG1vcmUgdGhvcm91Z2ggaXRlcmF0aXZlIGFsZ29yaXRobVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBsb29rcyBzb21ld2hhdCBiZXR0ZXIsIGJ1dCBpcyAqbXVjaCogc2xvd2VyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCByYXRpbyA9IDA7IHJhdGlvIDwgNjQ7IHJhdGlvKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaTEgPT09IGkyICYmIHJhdGlvID4gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcjY0ID0gcmF0aW8gLyA2NDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDM7IGorKylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWl4W2pdID0gY2wxW2pdICsgcjY0ICogKGNsMltqXSAtIGNsMVtqXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBkaXN0YW5jZSBiZXR3ZWVuIGNvbXBvbmVudHMgd2UgY2FsY3VsYXRlZCBlYXJsaWVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlzdCA9IHBhbGV0dGVEaXN0YW5jZXNbaTEgKiBwYWxldHRlLmRhdGEubGVuZ3RoICsgaTJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gZXZhbE1peEVycm9yKGNvbG9yLCBtaXgsIGRpc3QsIHI2NCAtIDAuNSwgZGlzdEZuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgPCBtaW5FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5FcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWl4LmNvbG9yMSA9IGNsMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1peC5jb2xvcjIgPSBjbDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNaXgucmF0aW8gPSByNjQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCAzOyBqKyspXG4gICAgICAgICAgICAgICAgZGF0YUluLmRhdGFbaSArIGpdID0gbWFwVmFsdWUgPCBiZXN0TWl4LnJhdGlvID9cbiAgICAgICAgICAgICAgICAgICAgYmVzdE1peC5jb2xvcjJbal0gOlxuICAgICAgICAgICAgICAgICAgICBiZXN0TWl4LmNvbG9yMVtqXTtcbiAgICAgICAgICAgIGlmIChpICUgKGxpbmUgKiA0KSA9PT0gMCAmJiBjYlByb2dyZXNzKVxuICAgICAgICAgICAgICAgIGNiUHJvZ3Jlc3MoaSwgc2l6ZSwgZGF0YUluKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YUluO1xuICAgIH07XG59XG5leHBvcnQgY29uc3QgQmF5ZXJMaWtlRmFzdCA9IHtcbiAgICBpZDogJ1Byb2NCYXllckxpa2VGYXN0JyxcbiAgICBuYW1lOiAnT3JkZXJlZCAoQmF5ZXItbGlrZSkg4oCTIEZhc3QnLFxuICAgIHByb2NGbjogcHJvY2Vzc0JheWVyKCksXG4gICAgbWF4QWxsb3dlZFBhbGV0dGVTaXplOiAxOTIsXG4gICAgc3VwcG9ydHM6IHtcbiAgICAgICAgdGhyZWFkczogdHJ1ZSxcbiAgICAgICAgZ2FtbWE6IGZhbHNlIC8vIE5vdCBpbXBsZW1lbnRlZFxuICAgIH0sXG4gICAgY29tcGxleGl0eTogKG4pID0+IChuICogbiAvIDIpIC8vIE8obsKyLzIpXG59O1xuZXhwb3J0IGNvbnN0IEJheWVyTGlrZSA9IHtcbiAgICBpZDogJ1Byb2NCYXllckxpa2VUaG9yb3VnaCcsXG4gICAgbmFtZTogJ09yZGVyZWQgKEJheWVyLWxpa2UpIOKAkyBIaWdoIFF1YWxpdHknLFxuICAgIHByb2NGbjogcHJvY2Vzc0JheWVyKGZhbHNlKSxcbiAgICBtYXhBbGxvd2VkUGFsZXR0ZVNpemU6IDI0LFxuICAgIHN1cHBvcnRzOiB7XG4gICAgICAgIHRocmVhZHM6IHRydWUsXG4gICAgICAgIGdhbW1hOiBmYWxzZSAvLyBOb3QgaW1wbGVtZW50ZWRcbiAgICB9LFxuICAgIGNvbXBsZXhpdHk6IChuKSA9PiAobiAqIG4gKiAzMikgLy8gTyhuwrIvMiAqIDY0KVxufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/process/processes/BayerLike.ts\n");

/***/ }),

/***/ "./src/process/processes/FloydSteinberg.ts":
/*!*************************************************!*\
  !*** ./src/process/processes/FloydSteinberg.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _palette_PaletteGroups__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../palette/PaletteGroups */ \"./src/palette/PaletteGroups.ts\");\n/* harmony import */ var _palette_paletteMap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../palette/paletteMap */ \"./src/palette/paletteMap.ts\");\n/* harmony import */ var _utils_colorUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/colorUtils */ \"./src/utils/colorUtils.ts\");\n\n\n\nconst processFloydSteinberg = (dataIn, palette, distFn, features, cbProgress) => {\n    const size = dataIn.width * dataIn.height * 4;\n    const line = dataIn.width * 4;\n    if (features.gamma) {\n        for (let i = 0; i < size; i += 4) {\n            const linear = (0,_utils_colorUtils__WEBPACK_IMPORTED_MODULE_2__.srgb2linear)(Array.from(dataIn.data.slice(i, i + 3)));\n            for (let j = 0; j < 3; j++)\n                dataIn.data[i + j] = linear[j];\n        }\n        palette = {\n            name: 'GENERATED_LINEAR',\n            type: _palette_PaletteGroups__WEBPACK_IMPORTED_MODULE_0__.default.POther,\n            useAlpha: false,\n            data: palette.data.map(color => (0,_utils_colorUtils__WEBPACK_IMPORTED_MODULE_2__.srgb2linear)(color))\n        };\n    }\n    for (let i = 0; i < size; i += 4) {\n        const color = Array.from(dataIn.data.slice(i, i + 3));\n        const mapped = (0,_palette_paletteMap__WEBPACK_IMPORTED_MODULE_1__.paletteMap)(color, palette, distFn);\n        for (let j = 0; j < 3; j++)\n            dataIn.data[i + j] = (features.gamma ? (0,_utils_colorUtils__WEBPACK_IMPORTED_MODULE_2__.linear2srgb)(mapped) : mapped)[j];\n        const error = color.map((ch, i) => ch - mapped[i]);\n        for (let j = 0; j < 3; j++) {\n            dataIn.data[i + 4 + j] += error[j] * 7 / 16;\n            dataIn.data[i + line - 4 + j] += error[j] * 3 / 16;\n            dataIn.data[i + line + j] += error[j] * 5 / 16;\n            dataIn.data[i + line + 4 + j] += error[j] * 1 / 16;\n        }\n        if (i % (4 * line) === 0 && cbProgress)\n            cbProgress(i, size, dataIn);\n    }\n    return dataIn;\n};\nconst FloydSteinberg = {\n    id: 'ProcFloydSteinberg',\n    name: 'Floyd–Steinberg',\n    procFn: processFloydSteinberg,\n    maxAllowedPaletteSize: 65536,\n    supports: {\n        threads: false,\n        gamma: true\n    },\n    complexity: (n) => n\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FloydSteinberg);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbWFnZWJpdGRlcHRoLy4vc3JjL3Byb2Nlc3MvcHJvY2Vzc2VzL0Zsb3lkU3RlaW5iZXJnLnRzPzA5YmYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFzRDtBQUNBO0FBQ1k7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsVUFBVTtBQUNqQywyQkFBMkIsOERBQVc7QUFDdEMsMkJBQTJCLE9BQU87QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0VBQWtCO0FBQ3BDO0FBQ0EsNENBQTRDLDhEQUFXO0FBQ3ZEO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBLHVCQUF1QiwrREFBVTtBQUNqQyx1QkFBdUIsT0FBTztBQUM5QixtREFBbUQsOERBQVc7QUFDOUQ7QUFDQSx1QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGlFQUFlLGNBQWMsRUFBQyIsImZpbGUiOiIuL3NyYy9wcm9jZXNzL3Byb2Nlc3Nlcy9GbG95ZFN0ZWluYmVyZy50cy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBQYWxldHRlVHlwZSBmcm9tICcuLi8uLi9wYWxldHRlL1BhbGV0dGVHcm91cHMnO1xuaW1wb3J0IHsgcGFsZXR0ZU1hcCB9IGZyb20gJy4uLy4uL3BhbGV0dGUvcGFsZXR0ZU1hcCc7XG5pbXBvcnQgeyBsaW5lYXIyc3JnYiwgc3JnYjJsaW5lYXIgfSBmcm9tICcuLi8uLi91dGlscy9jb2xvclV0aWxzJztcbmNvbnN0IHByb2Nlc3NGbG95ZFN0ZWluYmVyZyA9IChkYXRhSW4sIHBhbGV0dGUsIGRpc3RGbiwgZmVhdHVyZXMsIGNiUHJvZ3Jlc3MpID0+IHtcbiAgICBjb25zdCBzaXplID0gZGF0YUluLndpZHRoICogZGF0YUluLmhlaWdodCAqIDQ7XG4gICAgY29uc3QgbGluZSA9IGRhdGFJbi53aWR0aCAqIDQ7XG4gICAgaWYgKGZlYXR1cmVzLmdhbW1hKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSArPSA0KSB7XG4gICAgICAgICAgICBjb25zdCBsaW5lYXIgPSBzcmdiMmxpbmVhcihBcnJheS5mcm9tKGRhdGFJbi5kYXRhLnNsaWNlKGksIGkgKyAzKSkpO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCAzOyBqKyspXG4gICAgICAgICAgICAgICAgZGF0YUluLmRhdGFbaSArIGpdID0gbGluZWFyW2pdO1xuICAgICAgICB9XG4gICAgICAgIHBhbGV0dGUgPSB7XG4gICAgICAgICAgICBuYW1lOiAnR0VORVJBVEVEX0xJTkVBUicsXG4gICAgICAgICAgICB0eXBlOiBQYWxldHRlVHlwZS5QT3RoZXIsXG4gICAgICAgICAgICB1c2VBbHBoYTogZmFsc2UsXG4gICAgICAgICAgICBkYXRhOiBwYWxldHRlLmRhdGEubWFwKGNvbG9yID0+IHNyZ2IybGluZWFyKGNvbG9yKSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpICs9IDQpIHtcbiAgICAgICAgY29uc3QgY29sb3IgPSBBcnJheS5mcm9tKGRhdGFJbi5kYXRhLnNsaWNlKGksIGkgKyAzKSk7XG4gICAgICAgIGNvbnN0IG1hcHBlZCA9IHBhbGV0dGVNYXAoY29sb3IsIHBhbGV0dGUsIGRpc3RGbik7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgMzsgaisrKVxuICAgICAgICAgICAgZGF0YUluLmRhdGFbaSArIGpdID0gKGZlYXR1cmVzLmdhbW1hID8gbGluZWFyMnNyZ2IobWFwcGVkKSA6IG1hcHBlZClbal07XG4gICAgICAgIGNvbnN0IGVycm9yID0gY29sb3IubWFwKChjaCwgaSkgPT4gY2ggLSBtYXBwZWRbaV0pO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDM7IGorKykge1xuICAgICAgICAgICAgZGF0YUluLmRhdGFbaSArIDQgKyBqXSArPSBlcnJvcltqXSAqIDcgLyAxNjtcbiAgICAgICAgICAgIGRhdGFJbi5kYXRhW2kgKyBsaW5lIC0gNCArIGpdICs9IGVycm9yW2pdICogMyAvIDE2O1xuICAgICAgICAgICAgZGF0YUluLmRhdGFbaSArIGxpbmUgKyBqXSArPSBlcnJvcltqXSAqIDUgLyAxNjtcbiAgICAgICAgICAgIGRhdGFJbi5kYXRhW2kgKyBsaW5lICsgNCArIGpdICs9IGVycm9yW2pdICogMSAvIDE2O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpICUgKDQgKiBsaW5lKSA9PT0gMCAmJiBjYlByb2dyZXNzKVxuICAgICAgICAgICAgY2JQcm9ncmVzcyhpLCBzaXplLCBkYXRhSW4pO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YUluO1xufTtcbmNvbnN0IEZsb3lkU3RlaW5iZXJnID0ge1xuICAgIGlkOiAnUHJvY0Zsb3lkU3RlaW5iZXJnJyxcbiAgICBuYW1lOiAnRmxveWTigJNTdGVpbmJlcmcnLFxuICAgIHByb2NGbjogcHJvY2Vzc0Zsb3lkU3RlaW5iZXJnLFxuICAgIG1heEFsbG93ZWRQYWxldHRlU2l6ZTogNjU1MzYsXG4gICAgc3VwcG9ydHM6IHtcbiAgICAgICAgdGhyZWFkczogZmFsc2UsXG4gICAgICAgIGdhbW1hOiB0cnVlXG4gICAgfSxcbiAgICBjb21wbGV4aXR5OiAobikgPT4gblxufTtcbmV4cG9ydCBkZWZhdWx0IEZsb3lkU3RlaW5iZXJnO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/process/processes/FloydSteinberg.ts\n");

/***/ }),

/***/ "./src/process/processes/Weighted.ts":
/*!*******************************************!*\
  !*** ./src/process/processes/Weighted.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n// 8x8 threshold map\nconst threshold = [\n    0, 48, 12, 60, 3, 51, 15, 63,\n    32, 16, 44, 28, 35, 19, 47, 31,\n    8, 56, 4, 52, 11, 59, 7, 55,\n    40, 24, 36, 20, 43, 27, 39, 23,\n    2, 50, 14, 62, 1, 49, 13, 61,\n    34, 18, 46, 30, 33, 17, 45, 29,\n    10, 58, 6, 54, 9, 57, 5, 53,\n    42, 26, 38, 22, 41, 25, 37, 21\n].map(v => v / 64.0);\nconst processWeightedColormap = (dataIn, palette, distFn, features, cbProgress) => {\n    const gamma = 2.2;\n    const invGamma = 1 / gamma;\n    const size = dataIn.width * dataIn.height * 4;\n    const line = dataIn.width * 4;\n    const candidates = [];\n    let color, pColor;\n    let colorSum, avgWithCandidate;\n    // Precalculate luminance table and gamma-corrected palette\n    const luma = palette.data.map(color => color[0] * 299 + color[0] * 587 + color[0] * 114);\n    const gPalette = (features.gamma) ?\n        palette.data.map(color => color.map(ch => Math.pow(ch / 255, gamma))) :\n        [];\n    for (let i = 0; i < size; i += 4) {\n        color = Array.from(dataIn.data.slice(i, i + 4));\n        const x = (i % line) / 4;\n        const y = ~~(i / line);\n        candidates.splice(0); // Colors that may be used, weighted by repetition\n        colorSum = [0, 0, 0]; // Accumulating sum of all candidates, gamma corrected\n        while (candidates.length < 16) {\n            let candidate = 0; // Candidate to add\n            let weight = 1;\n            let minError = Number.MAX_VALUE;\n            // Max weight for a new candidate increases with number/weight of candidates\n            const maxWeight = (candidates.length || 1);\n            // Pick best color in palette as new candidate\n            for (let p = 0; p < palette.data.length; p++) {\n                pColor = (features.gamma ? gPalette : palette.data)[p];\n                for (let add = 1; add <= maxWeight; add *= 2) {\n                    // Sum if the candidate was added with its current weight (gamma -> standard)\n                    if (features.gamma)\n                        avgWithCandidate = colorSum.map((v, i) => Math.pow((v + pColor[i] * add) / (candidates.length + add), invGamma) * 255);\n                    else\n                        avgWithCandidate = colorSum.map((v, i) => (v + pColor[i] * add) / (candidates.length + add));\n                    // Error with this candidate and weight\n                    const error = distFn(avgWithCandidate, color);\n                    if (error < minError) {\n                        weight = add;\n                        candidate = p;\n                        minError = error;\n                    }\n                }\n            }\n            for (let j = 0; j < weight; j++)\n                candidates.push(candidate);\n            colorSum = colorSum.map((ch, i) => ch + (features.gamma ? gPalette : palette.data)[candidate][i] * weight);\n        }\n        candidates.sort((a, b) => luma[a] - luma[b]);\n        const index = ~~(threshold[(x % 8) + (y % 8) * 8] * candidates.length);\n        for (let j = 0; j < 3; j++)\n            dataIn.data[i + j] = palette.data[candidates[index]][j];\n        if (i % (4 * line) === 0 && cbProgress)\n            cbProgress(i, size, dataIn);\n    }\n    return dataIn;\n};\nconst WeightedColorMap = {\n    id: 'ProcWeightedColorMap',\n    name: 'Ordered (Weighted Color Map)',\n    procFn: processWeightedColormap,\n    maxAllowedPaletteSize: 256,\n    supports: {\n        threads: true,\n        gamma: true\n    },\n    complexity: (n) => (n * 384) // Based on worst case of O(n * 64 * log₂64), actual execution should be much faster\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (WeightedColorMap);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbWFnZWJpdGRlcHRoLy4vc3JjL3Byb2Nlc3MvcHJvY2Vzc2VzL1dlaWdodGVkLnRzPzA2NmIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixVQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0I7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix5QkFBeUI7QUFDcEQ7QUFDQSxpQ0FBaUMsa0JBQWtCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsWUFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLE9BQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsaUVBQWUsZ0JBQWdCLEVBQUMiLCJmaWxlIjoiLi9zcmMvcHJvY2Vzcy9wcm9jZXNzZXMvV2VpZ2h0ZWQudHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyA4eDggdGhyZXNob2xkIG1hcFxuY29uc3QgdGhyZXNob2xkID0gW1xuICAgIDAsIDQ4LCAxMiwgNjAsIDMsIDUxLCAxNSwgNjMsXG4gICAgMzIsIDE2LCA0NCwgMjgsIDM1LCAxOSwgNDcsIDMxLFxuICAgIDgsIDU2LCA0LCA1MiwgMTEsIDU5LCA3LCA1NSxcbiAgICA0MCwgMjQsIDM2LCAyMCwgNDMsIDI3LCAzOSwgMjMsXG4gICAgMiwgNTAsIDE0LCA2MiwgMSwgNDksIDEzLCA2MSxcbiAgICAzNCwgMTgsIDQ2LCAzMCwgMzMsIDE3LCA0NSwgMjksXG4gICAgMTAsIDU4LCA2LCA1NCwgOSwgNTcsIDUsIDUzLFxuICAgIDQyLCAyNiwgMzgsIDIyLCA0MSwgMjUsIDM3LCAyMVxuXS5tYXAodiA9PiB2IC8gNjQuMCk7XG5jb25zdCBwcm9jZXNzV2VpZ2h0ZWRDb2xvcm1hcCA9IChkYXRhSW4sIHBhbGV0dGUsIGRpc3RGbiwgZmVhdHVyZXMsIGNiUHJvZ3Jlc3MpID0+IHtcbiAgICBjb25zdCBnYW1tYSA9IDIuMjtcbiAgICBjb25zdCBpbnZHYW1tYSA9IDEgLyBnYW1tYTtcbiAgICBjb25zdCBzaXplID0gZGF0YUluLndpZHRoICogZGF0YUluLmhlaWdodCAqIDQ7XG4gICAgY29uc3QgbGluZSA9IGRhdGFJbi53aWR0aCAqIDQ7XG4gICAgY29uc3QgY2FuZGlkYXRlcyA9IFtdO1xuICAgIGxldCBjb2xvciwgcENvbG9yO1xuICAgIGxldCBjb2xvclN1bSwgYXZnV2l0aENhbmRpZGF0ZTtcbiAgICAvLyBQcmVjYWxjdWxhdGUgbHVtaW5hbmNlIHRhYmxlIGFuZCBnYW1tYS1jb3JyZWN0ZWQgcGFsZXR0ZVxuICAgIGNvbnN0IGx1bWEgPSBwYWxldHRlLmRhdGEubWFwKGNvbG9yID0+IGNvbG9yWzBdICogMjk5ICsgY29sb3JbMF0gKiA1ODcgKyBjb2xvclswXSAqIDExNCk7XG4gICAgY29uc3QgZ1BhbGV0dGUgPSAoZmVhdHVyZXMuZ2FtbWEpID9cbiAgICAgICAgcGFsZXR0ZS5kYXRhLm1hcChjb2xvciA9PiBjb2xvci5tYXAoY2ggPT4gTWF0aC5wb3coY2ggLyAyNTUsIGdhbW1hKSkpIDpcbiAgICAgICAgW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpICs9IDQpIHtcbiAgICAgICAgY29sb3IgPSBBcnJheS5mcm9tKGRhdGFJbi5kYXRhLnNsaWNlKGksIGkgKyA0KSk7XG4gICAgICAgIGNvbnN0IHggPSAoaSAlIGxpbmUpIC8gNDtcbiAgICAgICAgY29uc3QgeSA9IH5+KGkgLyBsaW5lKTtcbiAgICAgICAgY2FuZGlkYXRlcy5zcGxpY2UoMCk7IC8vIENvbG9ycyB0aGF0IG1heSBiZSB1c2VkLCB3ZWlnaHRlZCBieSByZXBldGl0aW9uXG4gICAgICAgIGNvbG9yU3VtID0gWzAsIDAsIDBdOyAvLyBBY2N1bXVsYXRpbmcgc3VtIG9mIGFsbCBjYW5kaWRhdGVzLCBnYW1tYSBjb3JyZWN0ZWRcbiAgICAgICAgd2hpbGUgKGNhbmRpZGF0ZXMubGVuZ3RoIDwgMTYpIHtcbiAgICAgICAgICAgIGxldCBjYW5kaWRhdGUgPSAwOyAvLyBDYW5kaWRhdGUgdG8gYWRkXG4gICAgICAgICAgICBsZXQgd2VpZ2h0ID0gMTtcbiAgICAgICAgICAgIGxldCBtaW5FcnJvciA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgICAgICAvLyBNYXggd2VpZ2h0IGZvciBhIG5ldyBjYW5kaWRhdGUgaW5jcmVhc2VzIHdpdGggbnVtYmVyL3dlaWdodCBvZiBjYW5kaWRhdGVzXG4gICAgICAgICAgICBjb25zdCBtYXhXZWlnaHQgPSAoY2FuZGlkYXRlcy5sZW5ndGggfHwgMSk7XG4gICAgICAgICAgICAvLyBQaWNrIGJlc3QgY29sb3IgaW4gcGFsZXR0ZSBhcyBuZXcgY2FuZGlkYXRlXG4gICAgICAgICAgICBmb3IgKGxldCBwID0gMDsgcCA8IHBhbGV0dGUuZGF0YS5sZW5ndGg7IHArKykge1xuICAgICAgICAgICAgICAgIHBDb2xvciA9IChmZWF0dXJlcy5nYW1tYSA/IGdQYWxldHRlIDogcGFsZXR0ZS5kYXRhKVtwXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBhZGQgPSAxOyBhZGQgPD0gbWF4V2VpZ2h0OyBhZGQgKj0gMikge1xuICAgICAgICAgICAgICAgICAgICAvLyBTdW0gaWYgdGhlIGNhbmRpZGF0ZSB3YXMgYWRkZWQgd2l0aCBpdHMgY3VycmVudCB3ZWlnaHQgKGdhbW1hIC0+IHN0YW5kYXJkKVxuICAgICAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZXMuZ2FtbWEpXG4gICAgICAgICAgICAgICAgICAgICAgICBhdmdXaXRoQ2FuZGlkYXRlID0gY29sb3JTdW0ubWFwKCh2LCBpKSA9PiBNYXRoLnBvdygodiArIHBDb2xvcltpXSAqIGFkZCkgLyAoY2FuZGlkYXRlcy5sZW5ndGggKyBhZGQpLCBpbnZHYW1tYSkgKiAyNTUpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBhdmdXaXRoQ2FuZGlkYXRlID0gY29sb3JTdW0ubWFwKCh2LCBpKSA9PiAodiArIHBDb2xvcltpXSAqIGFkZCkgLyAoY2FuZGlkYXRlcy5sZW5ndGggKyBhZGQpKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRXJyb3Igd2l0aCB0aGlzIGNhbmRpZGF0ZSBhbmQgd2VpZ2h0XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gZGlzdEZuKGF2Z1dpdGhDYW5kaWRhdGUsIGNvbG9yKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yIDwgbWluRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdlaWdodCA9IGFkZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbmRpZGF0ZSA9IHA7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5FcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB3ZWlnaHQ7IGorKylcbiAgICAgICAgICAgICAgICBjYW5kaWRhdGVzLnB1c2goY2FuZGlkYXRlKTtcbiAgICAgICAgICAgIGNvbG9yU3VtID0gY29sb3JTdW0ubWFwKChjaCwgaSkgPT4gY2ggKyAoZmVhdHVyZXMuZ2FtbWEgPyBnUGFsZXR0ZSA6IHBhbGV0dGUuZGF0YSlbY2FuZGlkYXRlXVtpXSAqIHdlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgY2FuZGlkYXRlcy5zb3J0KChhLCBiKSA9PiBsdW1hW2FdIC0gbHVtYVtiXSk7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gfn4odGhyZXNob2xkWyh4ICUgOCkgKyAoeSAlIDgpICogOF0gKiBjYW5kaWRhdGVzLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgMzsgaisrKVxuICAgICAgICAgICAgZGF0YUluLmRhdGFbaSArIGpdID0gcGFsZXR0ZS5kYXRhW2NhbmRpZGF0ZXNbaW5kZXhdXVtqXTtcbiAgICAgICAgaWYgKGkgJSAoNCAqIGxpbmUpID09PSAwICYmIGNiUHJvZ3Jlc3MpXG4gICAgICAgICAgICBjYlByb2dyZXNzKGksIHNpemUsIGRhdGFJbik7XG4gICAgfVxuICAgIHJldHVybiBkYXRhSW47XG59O1xuY29uc3QgV2VpZ2h0ZWRDb2xvck1hcCA9IHtcbiAgICBpZDogJ1Byb2NXZWlnaHRlZENvbG9yTWFwJyxcbiAgICBuYW1lOiAnT3JkZXJlZCAoV2VpZ2h0ZWQgQ29sb3IgTWFwKScsXG4gICAgcHJvY0ZuOiBwcm9jZXNzV2VpZ2h0ZWRDb2xvcm1hcCxcbiAgICBtYXhBbGxvd2VkUGFsZXR0ZVNpemU6IDI1NixcbiAgICBzdXBwb3J0czoge1xuICAgICAgICB0aHJlYWRzOiB0cnVlLFxuICAgICAgICBnYW1tYTogdHJ1ZVxuICAgIH0sXG4gICAgY29tcGxleGl0eTogKG4pID0+IChuICogMzg0KSAvLyBCYXNlZCBvbiB3b3JzdCBjYXNlIG9mIE8obiAqIDY0ICogbG9n4oKCNjQpLCBhY3R1YWwgZXhlY3V0aW9uIHNob3VsZCBiZSBtdWNoIGZhc3RlclxufTtcbmV4cG9ydCBkZWZhdWx0IFdlaWdodGVkQ29sb3JNYXA7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/process/processes/Weighted.ts\n");

/***/ }),

/***/ "./src/utils/colorUtils.ts":
/*!*********************************!*\
  !*** ./src/utils/colorUtils.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"luma_srgb\": () => (/* binding */ luma_srgb),\n/* harmony export */   \"luma_linear\": () => (/* binding */ luma_linear),\n/* harmony export */   \"srgb2linear\": () => (/* binding */ srgb2linear),\n/* harmony export */   \"linear2srgb\": () => (/* binding */ linear2srgb),\n/* harmony export */   \"srgb2xyz\": () => (/* binding */ srgb2xyz),\n/* harmony export */   \"xyz2srgb\": () => (/* binding */ xyz2srgb),\n/* harmony export */   \"xyz2lab\": () => (/* binding */ xyz2lab),\n/* harmony export */   \"lab2xyz\": () => (/* binding */ lab2xyz),\n/* harmony export */   \"srgb2lab\": () => (/* binding */ srgb2lab),\n/* harmony export */   \"lab2srgb\": () => (/* binding */ lab2srgb)\n/* harmony export */ });\n// Utility functions specific to color handling\n// There are enough of these to put in a separate file\n// Formula reference: http://www.easyrgb.com/en/math.php\n// All conversions use a D65/2° standard illuminant where applicable\n// Gets luminance for a color in sRGB\nfunction luma_srgb(rgb) {\n    return (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / (255.0 * 1000);\n}\nfunction luma_linear(lrgb) {\n    return lrgb[0] * 0.2126 + lrgb[1] * 0.7152 + lrgb[2] * 0.0722;\n}\n// Converts sRGB to linear RGB\nfunction srgb2linear(rgb, gamma = 2.2) {\n    return rgb.map(val => {\n        let vNew = val / 255.0;\n        vNew = (vNew > 0.04045) ?\n            Math.pow((vNew + 0.055) / 1.055, gamma) :\n            vNew / 12.92;\n        return vNew * 100;\n    });\n}\n// Converts linear RGB to sRGB\nfunction linear2srgb(lrgb, gamma = 2.2) {\n    return lrgb.map(val => {\n        let vNew = val / 100.0;\n        vNew = (vNew > 0.0031308) ?\n            1.055 * Math.pow(vNew, 1 / gamma) - 0.055 :\n            vNew * 12.92;\n        return ~~(vNew * 255);\n    });\n}\n// Converts sRGB to XYZ color space\nfunction srgb2xyz(rgb, gamma = 2.2) {\n    const lrgb = srgb2linear(rgb, gamma);\n    return [\n        lrgb[0] * 0.4124 + lrgb[1] * 0.3576 + lrgb[2] * 0.1805,\n        lrgb[0] * 0.2126 + lrgb[1] * 0.7152 + lrgb[2] * 0.0722,\n        lrgb[0] * 0.0193 + lrgb[1] * 0.1192 + lrgb[2] * 0.9505 // Z\n    ];\n}\n// Converts XYZ color space to sRGB\nfunction xyz2srgb(xyz, gamma = 2.2) {\n    const lrgb = [\n        xyz[0] * 3.2406 + xyz[1] * -1.5372 + xyz[2] * -0.4986,\n        xyz[0] * -0.9689 + xyz[1] * 1.8758 + xyz[2] * 0.0415,\n        xyz[0] * 0.0557 + xyz[1] * -0.2040 + xyz[2] * 1.0570\n    ];\n    return linear2srgb(lrgb, gamma);\n}\n// Converts XYZ color to CIE-L*ab\nfunction xyz2lab(xyz) {\n    let ixyz = [\n        xyz[0] * 95.047,\n        xyz[1] * 100.000,\n        xyz[2] * 108.883\n    ];\n    ixyz = ixyz.map(val => (val > 0.008856) ?\n        Math.pow(val, 1 / 3) :\n        (val * 7.787) + (16 / 116));\n    return [\n        (116 * ixyz[1]) - 16,\n        500 * (ixyz[0] - ixyz[1]),\n        200 * (ixyz[1] - ixyz[2]) // b\n    ];\n}\n// Converts CIE-L*ab to XYZ color\nfunction lab2xyz(lab) {\n    const iy = (lab[0] + 16) / 116;\n    let ixyz = [\n        lab[1] / 500 + iy,\n        iy,\n        iy - (lab[2] / 200)\n    ];\n    ixyz = ixyz.map(val => {\n        const cubed = Math.pow(val, 3);\n        return (cubed > 0.008856) ?\n            cubed :\n            (val - 16 / 116) / 7.787;\n    });\n    return [\n        ixyz[0] * 95.047,\n        ixyz[1] * 100.000,\n        ixyz[2] * 108.883\n    ];\n}\n// Converts sRGB to CIE-L*ab\nfunction srgb2lab(rgb, gamma = 2.2) {\n    return xyz2lab(srgb2xyz(rgb, gamma));\n}\n// Converts CIE-L*ab to sRGB\nfunction lab2srgb(rgb, gamma = 2.2) {\n    return xyz2srgb(lab2xyz(rgb), gamma);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbWFnZWJpdGRlcHRoLy4vc3JjL3V0aWxzL2NvbG9yVXRpbHMudHM/NTFiZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBIiwiZmlsZSI6Ii4vc3JjL3V0aWxzL2NvbG9yVXRpbHMudHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBVdGlsaXR5IGZ1bmN0aW9ucyBzcGVjaWZpYyB0byBjb2xvciBoYW5kbGluZ1xuLy8gVGhlcmUgYXJlIGVub3VnaCBvZiB0aGVzZSB0byBwdXQgaW4gYSBzZXBhcmF0ZSBmaWxlXG4vLyBGb3JtdWxhIHJlZmVyZW5jZTogaHR0cDovL3d3dy5lYXN5cmdiLmNvbS9lbi9tYXRoLnBocFxuLy8gQWxsIGNvbnZlcnNpb25zIHVzZSBhIEQ2NS8ywrAgc3RhbmRhcmQgaWxsdW1pbmFudCB3aGVyZSBhcHBsaWNhYmxlXG4vLyBHZXRzIGx1bWluYW5jZSBmb3IgYSBjb2xvciBpbiBzUkdCXG5leHBvcnQgZnVuY3Rpb24gbHVtYV9zcmdiKHJnYikge1xuICAgIHJldHVybiAocmdiWzBdICogMjk5ICsgcmdiWzFdICogNTg3ICsgcmdiWzJdICogMTE0KSAvICgyNTUuMCAqIDEwMDApO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGx1bWFfbGluZWFyKGxyZ2IpIHtcbiAgICByZXR1cm4gbHJnYlswXSAqIDAuMjEyNiArIGxyZ2JbMV0gKiAwLjcxNTIgKyBscmdiWzJdICogMC4wNzIyO1xufVxuLy8gQ29udmVydHMgc1JHQiB0byBsaW5lYXIgUkdCXG5leHBvcnQgZnVuY3Rpb24gc3JnYjJsaW5lYXIocmdiLCBnYW1tYSA9IDIuMikge1xuICAgIHJldHVybiByZ2IubWFwKHZhbCA9PiB7XG4gICAgICAgIGxldCB2TmV3ID0gdmFsIC8gMjU1LjA7XG4gICAgICAgIHZOZXcgPSAodk5ldyA+IDAuMDQwNDUpID9cbiAgICAgICAgICAgIE1hdGgucG93KCh2TmV3ICsgMC4wNTUpIC8gMS4wNTUsIGdhbW1hKSA6XG4gICAgICAgICAgICB2TmV3IC8gMTIuOTI7XG4gICAgICAgIHJldHVybiB2TmV3ICogMTAwO1xuICAgIH0pO1xufVxuLy8gQ29udmVydHMgbGluZWFyIFJHQiB0byBzUkdCXG5leHBvcnQgZnVuY3Rpb24gbGluZWFyMnNyZ2IobHJnYiwgZ2FtbWEgPSAyLjIpIHtcbiAgICByZXR1cm4gbHJnYi5tYXAodmFsID0+IHtcbiAgICAgICAgbGV0IHZOZXcgPSB2YWwgLyAxMDAuMDtcbiAgICAgICAgdk5ldyA9ICh2TmV3ID4gMC4wMDMxMzA4KSA/XG4gICAgICAgICAgICAxLjA1NSAqIE1hdGgucG93KHZOZXcsIDEgLyBnYW1tYSkgLSAwLjA1NSA6XG4gICAgICAgICAgICB2TmV3ICogMTIuOTI7XG4gICAgICAgIHJldHVybiB+fih2TmV3ICogMjU1KTtcbiAgICB9KTtcbn1cbi8vIENvbnZlcnRzIHNSR0IgdG8gWFlaIGNvbG9yIHNwYWNlXG5leHBvcnQgZnVuY3Rpb24gc3JnYjJ4eXoocmdiLCBnYW1tYSA9IDIuMikge1xuICAgIGNvbnN0IGxyZ2IgPSBzcmdiMmxpbmVhcihyZ2IsIGdhbW1hKTtcbiAgICByZXR1cm4gW1xuICAgICAgICBscmdiWzBdICogMC40MTI0ICsgbHJnYlsxXSAqIDAuMzU3NiArIGxyZ2JbMl0gKiAwLjE4MDUsXG4gICAgICAgIGxyZ2JbMF0gKiAwLjIxMjYgKyBscmdiWzFdICogMC43MTUyICsgbHJnYlsyXSAqIDAuMDcyMixcbiAgICAgICAgbHJnYlswXSAqIDAuMDE5MyArIGxyZ2JbMV0gKiAwLjExOTIgKyBscmdiWzJdICogMC45NTA1IC8vIFpcbiAgICBdO1xufVxuLy8gQ29udmVydHMgWFlaIGNvbG9yIHNwYWNlIHRvIHNSR0JcbmV4cG9ydCBmdW5jdGlvbiB4eXoyc3JnYih4eXosIGdhbW1hID0gMi4yKSB7XG4gICAgY29uc3QgbHJnYiA9IFtcbiAgICAgICAgeHl6WzBdICogMy4yNDA2ICsgeHl6WzFdICogLTEuNTM3MiArIHh5elsyXSAqIC0wLjQ5ODYsXG4gICAgICAgIHh5elswXSAqIC0wLjk2ODkgKyB4eXpbMV0gKiAxLjg3NTggKyB4eXpbMl0gKiAwLjA0MTUsXG4gICAgICAgIHh5elswXSAqIDAuMDU1NyArIHh5elsxXSAqIC0wLjIwNDAgKyB4eXpbMl0gKiAxLjA1NzBcbiAgICBdO1xuICAgIHJldHVybiBsaW5lYXIyc3JnYihscmdiLCBnYW1tYSk7XG59XG4vLyBDb252ZXJ0cyBYWVogY29sb3IgdG8gQ0lFLUwqYWJcbmV4cG9ydCBmdW5jdGlvbiB4eXoybGFiKHh5eikge1xuICAgIGxldCBpeHl6ID0gW1xuICAgICAgICB4eXpbMF0gKiA5NS4wNDcsXG4gICAgICAgIHh5elsxXSAqIDEwMC4wMDAsXG4gICAgICAgIHh5elsyXSAqIDEwOC44ODNcbiAgICBdO1xuICAgIGl4eXogPSBpeHl6Lm1hcCh2YWwgPT4gKHZhbCA+IDAuMDA4ODU2KSA/XG4gICAgICAgIE1hdGgucG93KHZhbCwgMSAvIDMpIDpcbiAgICAgICAgKHZhbCAqIDcuNzg3KSArICgxNiAvIDExNikpO1xuICAgIHJldHVybiBbXG4gICAgICAgICgxMTYgKiBpeHl6WzFdKSAtIDE2LFxuICAgICAgICA1MDAgKiAoaXh5elswXSAtIGl4eXpbMV0pLFxuICAgICAgICAyMDAgKiAoaXh5elsxXSAtIGl4eXpbMl0pIC8vIGJcbiAgICBdO1xufVxuLy8gQ29udmVydHMgQ0lFLUwqYWIgdG8gWFlaIGNvbG9yXG5leHBvcnQgZnVuY3Rpb24gbGFiMnh5eihsYWIpIHtcbiAgICBjb25zdCBpeSA9IChsYWJbMF0gKyAxNikgLyAxMTY7XG4gICAgbGV0IGl4eXogPSBbXG4gICAgICAgIGxhYlsxXSAvIDUwMCArIGl5LFxuICAgICAgICBpeSxcbiAgICAgICAgaXkgLSAobGFiWzJdIC8gMjAwKVxuICAgIF07XG4gICAgaXh5eiA9IGl4eXoubWFwKHZhbCA9PiB7XG4gICAgICAgIGNvbnN0IGN1YmVkID0gTWF0aC5wb3codmFsLCAzKTtcbiAgICAgICAgcmV0dXJuIChjdWJlZCA+IDAuMDA4ODU2KSA/XG4gICAgICAgICAgICBjdWJlZCA6XG4gICAgICAgICAgICAodmFsIC0gMTYgLyAxMTYpIC8gNy43ODc7XG4gICAgfSk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgaXh5elswXSAqIDk1LjA0NyxcbiAgICAgICAgaXh5elsxXSAqIDEwMC4wMDAsXG4gICAgICAgIGl4eXpbMl0gKiAxMDguODgzXG4gICAgXTtcbn1cbi8vIENvbnZlcnRzIHNSR0IgdG8gQ0lFLUwqYWJcbmV4cG9ydCBmdW5jdGlvbiBzcmdiMmxhYihyZ2IsIGdhbW1hID0gMi4yKSB7XG4gICAgcmV0dXJuIHh5ejJsYWIoc3JnYjJ4eXoocmdiLCBnYW1tYSkpO1xufVxuLy8gQ29udmVydHMgQ0lFLUwqYWIgdG8gc1JHQlxuZXhwb3J0IGZ1bmN0aW9uIGxhYjJzcmdiKHJnYiwgZ2FtbWEgPSAyLjIpIHtcbiAgICByZXR1cm4geHl6MnNyZ2IobGFiMnh5eihyZ2IpLCBnYW1tYSk7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/utils/colorUtils.ts\n");

/***/ }),

/***/ "./src/utils/utils.ts":
/*!****************************!*\
  !*** ./src/utils/utils.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"vec3distance\": () => (/* binding */ vec3distance),\n/* harmony export */   \"loadFile\": () => (/* binding */ loadFile),\n/* harmony export */   \"expandRGBPalette\": () => (/* binding */ expandRGBPalette),\n/* harmony export */   \"paletteSize\": () => (/* binding */ paletteSize),\n/* harmony export */   \"getComplexityRating\": () => (/* binding */ getComplexityRating)\n/* harmony export */ });\n/* harmony import */ var _palette_PaletteGroups__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../palette/PaletteGroups */ \"./src/palette/PaletteGroups.ts\");\n\n// General utility functions\nconst vec3distance = (a, b) => {\n    return (a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1]) + (a[2] - b[2]) * (a[2] - b[2]);\n};\nconst loadFile = (e) => {\n    return new Promise((resolve, reject) => {\n        const input = e.target;\n        if (input === null || input === void 0 ? void 0 : input.files) {\n            const file = input.files[0];\n            const img = new Image();\n            img.onload = () => resolve(img);\n            img.src = URL.createObjectURL(file);\n        }\n        else\n            reject();\n    });\n};\nconst expandRGBPalette = (palette) => {\n    if (palette.type !== _palette_PaletteGroups__WEBPACK_IMPORTED_MODULE_0__.default.PRGB)\n        throw new Error('Not an RGB palette');\n    const levels = palette.data[0].map(bits => Math.pow(2, bits));\n    const expanded = {\n        name: 'EXPANDED_RGB',\n        type: _palette_PaletteGroups__WEBPACK_IMPORTED_MODULE_0__.default.POther,\n        useAlpha: false,\n        data: []\n    };\n    for (let r = 0; r < levels[0]; r++)\n        for (let g = 0; g < levels[1]; g++)\n            for (let b = 0; b < levels[2]; b++) {\n                const segments = [r, g, b];\n                const clamped = [r, g, b];\n                for (let i = 0; i < 3; i++)\n                    clamped[i] = segments[i] * (255 / (levels[i] - 1));\n                expanded.data.push(clamped);\n            }\n    return expanded;\n};\nconst paletteSize = (pal) => {\n    switch (pal.type) {\n        case _palette_PaletteGroups__WEBPACK_IMPORTED_MODULE_0__.default.PRGB:\n            return Math.pow(2, pal.data[0][0]) * Math.pow(2, pal.data[0][1]) * Math.pow(2, pal.data[0][2]);\n        case _palette_PaletteGroups__WEBPACK_IMPORTED_MODULE_0__.default.PAuto:\n            return pal.data[0][0];\n        default:\n            return pal.data.length;\n    }\n};\nconst getComplexityRating = (process, palette) => {\n    return process.complexity(paletteSize(palette));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbWFnZWJpdGRlcHRoLy4vc3JjL3V0aWxzL3V0aWxzLnRzPzU2MjIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQW1EO0FBQ25EO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNPO0FBQ1AseUJBQXlCLGdFQUFnQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsa0VBQWtCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixlQUFlO0FBQ2xDLHVCQUF1QixlQUFlO0FBQ3RDLDJCQUEyQixlQUFlO0FBQzFDO0FBQ0E7QUFDQSwrQkFBK0IsT0FBTztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGFBQWEsZ0VBQWdCO0FBQzdCO0FBQ0EsYUFBYSxpRUFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSIsImZpbGUiOiIuL3NyYy91dGlscy91dGlscy50cy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBQYWxldHRlVHlwZSBmcm9tICcuLi9wYWxldHRlL1BhbGV0dGVHcm91cHMnO1xuLy8gR2VuZXJhbCB1dGlsaXR5IGZ1bmN0aW9uc1xuZXhwb3J0IGNvbnN0IHZlYzNkaXN0YW5jZSA9IChhLCBiKSA9PiB7XG4gICAgcmV0dXJuIChhWzBdIC0gYlswXSkgKiAoYVswXSAtIGJbMF0pICsgKGFbMV0gLSBiWzFdKSAqIChhWzFdIC0gYlsxXSkgKyAoYVsyXSAtIGJbMl0pICogKGFbMl0gLSBiWzJdKTtcbn07XG5leHBvcnQgY29uc3QgbG9hZEZpbGUgPSAoZSkgPT4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gZS50YXJnZXQ7XG4gICAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCB8fCBpbnB1dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5wdXQuZmlsZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbGUgPSBpbnB1dC5maWxlc1swXTtcbiAgICAgICAgICAgIGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgaW1nLm9ubG9hZCA9ICgpID0+IHJlc29sdmUoaW1nKTtcbiAgICAgICAgICAgIGltZy5zcmMgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGZpbGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJlamVjdCgpO1xuICAgIH0pO1xufTtcbmV4cG9ydCBjb25zdCBleHBhbmRSR0JQYWxldHRlID0gKHBhbGV0dGUpID0+IHtcbiAgICBpZiAocGFsZXR0ZS50eXBlICE9PSBQYWxldHRlVHlwZS5QUkdCKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhbiBSR0IgcGFsZXR0ZScpO1xuICAgIGNvbnN0IGxldmVscyA9IHBhbGV0dGUuZGF0YVswXS5tYXAoYml0cyA9PiBNYXRoLnBvdygyLCBiaXRzKSk7XG4gICAgY29uc3QgZXhwYW5kZWQgPSB7XG4gICAgICAgIG5hbWU6ICdFWFBBTkRFRF9SR0InLFxuICAgICAgICB0eXBlOiBQYWxldHRlVHlwZS5QT3RoZXIsXG4gICAgICAgIHVzZUFscGhhOiBmYWxzZSxcbiAgICAgICAgZGF0YTogW11cbiAgICB9O1xuICAgIGZvciAobGV0IHIgPSAwOyByIDwgbGV2ZWxzWzBdOyByKyspXG4gICAgICAgIGZvciAobGV0IGcgPSAwOyBnIDwgbGV2ZWxzWzFdOyBnKyspXG4gICAgICAgICAgICBmb3IgKGxldCBiID0gMDsgYiA8IGxldmVsc1syXTsgYisrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VnbWVudHMgPSBbciwgZywgYl07XG4gICAgICAgICAgICAgICAgY29uc3QgY2xhbXBlZCA9IFtyLCBnLCBiXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgY2xhbXBlZFtpXSA9IHNlZ21lbnRzW2ldICogKDI1NSAvIChsZXZlbHNbaV0gLSAxKSk7XG4gICAgICAgICAgICAgICAgZXhwYW5kZWQuZGF0YS5wdXNoKGNsYW1wZWQpO1xuICAgICAgICAgICAgfVxuICAgIHJldHVybiBleHBhbmRlZDtcbn07XG5leHBvcnQgY29uc3QgcGFsZXR0ZVNpemUgPSAocGFsKSA9PiB7XG4gICAgc3dpdGNoIChwYWwudHlwZSkge1xuICAgICAgICBjYXNlIFBhbGV0dGVUeXBlLlBSR0I6XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5wb3coMiwgcGFsLmRhdGFbMF1bMF0pICogTWF0aC5wb3coMiwgcGFsLmRhdGFbMF1bMV0pICogTWF0aC5wb3coMiwgcGFsLmRhdGFbMF1bMl0pO1xuICAgICAgICBjYXNlIFBhbGV0dGVUeXBlLlBBdXRvOlxuICAgICAgICAgICAgcmV0dXJuIHBhbC5kYXRhWzBdWzBdO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHBhbC5kYXRhLmxlbmd0aDtcbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IGdldENvbXBsZXhpdHlSYXRpbmcgPSAocHJvY2VzcywgcGFsZXR0ZSkgPT4ge1xuICAgIHJldHVybiBwcm9jZXNzLmNvbXBsZXhpdHkocGFsZXR0ZVNpemUocGFsZXR0ZSkpO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/utils/utils.ts\n");

/***/ }),

/***/ "./node_modules/ts-loader/index.js!./src/worker.ts":
/*!*********************************************************!*\
  !*** ./node_modules/ts-loader/index.js!./src/worker.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _colorDistance_CompareFn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./colorDistance/CompareFn */ \"./src/colorDistance/CompareFn.ts\");\n/* harmony import */ var _palette_PaletteGroups__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./palette/PaletteGroups */ \"./src/palette/PaletteGroups.ts\");\n/* harmony import */ var _paletteGen_getAutoPalette__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./paletteGen/getAutoPalette */ \"./src/paletteGen/getAutoPalette.ts\");\n/* harmony import */ var _process_Process__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./process/Process */ \"./src/process/Process.ts\");\n\n\n\n\n//import { ProcessEvent, ProgressFn } from './process/ProcessWorker';\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst ctx = self;\nvar ProcessEvent;\n(function (ProcessEvent) {\n    ProcessEvent[ProcessEvent[\"Progress\"] = 0] = \"Progress\";\n    ProcessEvent[ProcessEvent[\"Done\"] = 1] = \"Done\";\n    ProcessEvent[ProcessEvent[\"Error\"] = 2] = \"Error\";\n})(ProcessEvent || (ProcessEvent = {}));\nconst reportProgress = (current, total, partial) => {\n    ctx.postMessage({ msg: ProcessEvent.Progress, params: { current, total, partial } });\n};\nctx.addEventListener('message', (ev) => {\n    const msg = ev.data;\n    // Special handling for certain palettes\n    const palette = (msg.palette.type === _palette_PaletteGroups__WEBPACK_IMPORTED_MODULE_1__.default.PAuto) ?\n        (0,_paletteGen_getAutoPalette__WEBPACK_IMPORTED_MODULE_2__.getAutoPalette)(msg.palette, msg.dataIn) :\n        msg.palette;\n    // Convert image using the passed process\n    const process = (0,_process_Process__WEBPACK_IMPORTED_MODULE_3__.getProcessById)(msg.procId);\n    if (process) {\n        const distFn = (0,_colorDistance_CompareFn__WEBPACK_IMPORTED_MODULE_0__.getColorDistanceFnById)(msg.distFnId);\n        process.procFn(msg.dataIn, palette, distFn, msg.features, reportProgress);\n        ctx.postMessage({ msg: ProcessEvent.Done, params: { result: msg.dataIn } });\n        self.close();\n    }\n    else {\n        ctx.postMessage({ msg: ProcessEvent.Error, params: { error: 'bad procId' } });\n        self.close();\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbWFnZWJpdGRlcHRoLy4vc3JjL3dvcmtlci50cz80ODljIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQW1FO0FBQ2pCO0FBQ1c7QUFDVjtBQUNuRCxVQUFVLDJCQUEyQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0NBQW9DO0FBQ3JDO0FBQ0EscUJBQXFCLHNDQUFzQywwQkFBMEIsRUFBRTtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxpRUFBaUI7QUFDM0QsUUFBUSwwRUFBYztBQUN0QjtBQUNBO0FBQ0Esb0JBQW9CLGdFQUFjO0FBQ2xDO0FBQ0EsdUJBQXVCLGdGQUFzQjtBQUM3QztBQUNBLHlCQUF5QixrQ0FBa0MscUJBQXFCLEVBQUU7QUFDbEY7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG1DQUFtQyxzQkFBc0IsRUFBRTtBQUNwRjtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy90cy1sb2FkZXIvaW5kZXguanMhLi9zcmMvd29ya2VyLnRzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0Q29sb3JEaXN0YW5jZUZuQnlJZCB9IGZyb20gJy4vY29sb3JEaXN0YW5jZS9Db21wYXJlRm4nO1xuaW1wb3J0IFBhbGV0dGVUeXBlIGZyb20gJy4vcGFsZXR0ZS9QYWxldHRlR3JvdXBzJztcbmltcG9ydCB7IGdldEF1dG9QYWxldHRlIH0gZnJvbSAnLi9wYWxldHRlR2VuL2dldEF1dG9QYWxldHRlJztcbmltcG9ydCB7IGdldFByb2Nlc3NCeUlkIH0gZnJvbSAnLi9wcm9jZXNzL1Byb2Nlc3MnO1xuLy9pbXBvcnQgeyBQcm9jZXNzRXZlbnQsIFByb2dyZXNzRm4gfSBmcm9tICcuL3Byb2Nlc3MvUHJvY2Vzc1dvcmtlcic7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuY29uc3QgY3R4ID0gc2VsZjtcbnZhciBQcm9jZXNzRXZlbnQ7XG4oZnVuY3Rpb24gKFByb2Nlc3NFdmVudCkge1xuICAgIFByb2Nlc3NFdmVudFtQcm9jZXNzRXZlbnRbXCJQcm9ncmVzc1wiXSA9IDBdID0gXCJQcm9ncmVzc1wiO1xuICAgIFByb2Nlc3NFdmVudFtQcm9jZXNzRXZlbnRbXCJEb25lXCJdID0gMV0gPSBcIkRvbmVcIjtcbiAgICBQcm9jZXNzRXZlbnRbUHJvY2Vzc0V2ZW50W1wiRXJyb3JcIl0gPSAyXSA9IFwiRXJyb3JcIjtcbn0pKFByb2Nlc3NFdmVudCB8fCAoUHJvY2Vzc0V2ZW50ID0ge30pKTtcbmNvbnN0IHJlcG9ydFByb2dyZXNzID0gKGN1cnJlbnQsIHRvdGFsLCBwYXJ0aWFsKSA9PiB7XG4gICAgY3R4LnBvc3RNZXNzYWdlKHsgbXNnOiBQcm9jZXNzRXZlbnQuUHJvZ3Jlc3MsIHBhcmFtczogeyBjdXJyZW50LCB0b3RhbCwgcGFydGlhbCB9IH0pO1xufTtcbmN0eC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgKGV2KSA9PiB7XG4gICAgY29uc3QgbXNnID0gZXYuZGF0YTtcbiAgICAvLyBTcGVjaWFsIGhhbmRsaW5nIGZvciBjZXJ0YWluIHBhbGV0dGVzXG4gICAgY29uc3QgcGFsZXR0ZSA9IChtc2cucGFsZXR0ZS50eXBlID09PSBQYWxldHRlVHlwZS5QQXV0bykgP1xuICAgICAgICBnZXRBdXRvUGFsZXR0ZShtc2cucGFsZXR0ZSwgbXNnLmRhdGFJbikgOlxuICAgICAgICBtc2cucGFsZXR0ZTtcbiAgICAvLyBDb252ZXJ0IGltYWdlIHVzaW5nIHRoZSBwYXNzZWQgcHJvY2Vzc1xuICAgIGNvbnN0IHByb2Nlc3MgPSBnZXRQcm9jZXNzQnlJZChtc2cucHJvY0lkKTtcbiAgICBpZiAocHJvY2Vzcykge1xuICAgICAgICBjb25zdCBkaXN0Rm4gPSBnZXRDb2xvckRpc3RhbmNlRm5CeUlkKG1zZy5kaXN0Rm5JZCk7XG4gICAgICAgIHByb2Nlc3MucHJvY0ZuKG1zZy5kYXRhSW4sIHBhbGV0dGUsIGRpc3RGbiwgbXNnLmZlYXR1cmVzLCByZXBvcnRQcm9ncmVzcyk7XG4gICAgICAgIGN0eC5wb3N0TWVzc2FnZSh7IG1zZzogUHJvY2Vzc0V2ZW50LkRvbmUsIHBhcmFtczogeyByZXN1bHQ6IG1zZy5kYXRhSW4gfSB9KTtcbiAgICAgICAgc2VsZi5jbG9zZSgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY3R4LnBvc3RNZXNzYWdlKHsgbXNnOiBQcm9jZXNzRXZlbnQuRXJyb3IsIHBhcmFtczogeyBlcnJvcjogJ2JhZCBwcm9jSWQnIH0gfSk7XG4gICAgICAgIHNlbGYuY2xvc2UoKTtcbiAgICB9XG59KTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/ts-loader/index.js!./src/worker.ts\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	// startup
/******/ 	// Load entry module
/******/ 	__webpack_require__("./node_modules/ts-loader/index.js!./src/worker.ts");
/******/ 	// This entry module used 'exports' so it can't be inlined
/******/ })()
;